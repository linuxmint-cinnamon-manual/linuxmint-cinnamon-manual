[


{
"title": "Об этой книге",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca010_about_book.html",
"summary": "",
"body": "В основу этой книги легли заметки, посвящённые дистрибутиву Linux Mint идесктопу Cinnamon, которые на протяжении последнего года размещались на нашемБлогосайте. В ней использованы также фрагменты цикла статейна ту же тему, публиковавшиеся на сайте IBMdeveloperWorks (правда, цикл этот поне зависящим от меня обстоятельствам не был закончен). При подготовке книгиэти статьи и заметки были систематизированы, структурированы, отредактированыи актуализированы в соответствии с текущими реалиями, а также дополнены новымиматериалами.Автор не ставил себе целью написать последовательное и законченное руководствопо Linux Mint и Cinnamon. Это — именно очерки, посвящённые тем аспектамустройства и применения данного тандема, которые а) не очень подробно освещёныв имеющихся источниках и б) интересны лично автору. И вследствие последнегообстоятельства носят вполне субъективный характер.Дистрибутив Mint, по моему мнению, пригоден для применителей любого уровняначальной подготовки. Соответственно и книга о нём не предполагает у читателяналичия каких-то особенных познаний, кроме самого обычного любопытства. Атакже понимания того, что это — именно очерки, а не сборник документации.При этом читатель книги не обязан быть применителем именно Linux Mint.Дистрибутив этот является дериватом Ubuntu и сохраняет с ней практическиполную бинарную совместимость. Так что ряд описанных в книге вещёй (например,про управление пакетами) — общие для всего семейства Ubuntu&#39;идов, а отчасти идля всех deb based дистрибутивов, включая даже прародительский Debian. Кое-чтоже, скажем, включение поддержки LVM, softRAID, ZFS, имеет силу для всехдистрибутивов Linux вообще.Ну а сведения, содержащиеся в очерках про Cinnamon, приложимы к любомудистрибутиве, в котором этот десктоп может быть установлен, и в которомобеспечивается его корректная работа — список их постоянно расширяется, инынче включает в себя и не только Linux-, но и BSD-системы.Во время работы над книгой затронутые в ней вопросы обсуждались с моимитоварищами и коллегами: Владимиром Поповым, Сергеем Голубевым, ВладимиромРодионовым, СтаниславомШрамко, а также многочисленными участникамисоциальной сети Juick, форумов Linux MintРосинка и Matuntu, дляпоимённого перечисления которых не хватит никаких ресурсов. Всем именованным иподразумеваемых лицам автор выражает свою признательность.Отдельная благодарность — поэту-линуксоиду Ирине Киттель aka АлисаДеева, вдохновлявшей меня на трудовые свершения своимистихами, и моим детям — Ольге и Виктору, ставшими применителями Linux&#39;а пособственной инициативе.Наконец, автор искренне признателен команде разработчиков дистрибутива Mint иинтегрированной среды Cinnamon, и лично Клементу Лефевру aka Clem за созданиепрекрасного дистрибутива и его рабочего окружения.Примечание: книга в основных форматах для чтения в оффлайне доступна вБиблиотеке Блогосайта. Для неё, как и всехостальных книг Библиотеки, разрешается свободное использование инекоммерческое распространение в электронной форме при условии указанияавторства и активной индексируемой ссылки на первоисточник.Все книги Библиотеки доступны бесплатно, хотя автор не отказывается отаморального (то есть финансового) содействия своим проектам, оказать котороеможно, заглянув на эту страницу."
},




{
"title": "Введение в Linux Mint",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca020_linux_mint_into.html",
"summary": "",
"body": "Разговор о Mint и его Cinnamon логично начать с рассказа о том, что же такое,товарищи, Mint, и что такое, братья, Cinnamon. Начну с этого и я.Лирическое вступлениеВедь в науке, в основном, происходят вещи посредственные — и я приучил себя кпосредственному.Владимир Савченко, Открытие себяВ долгой истории дистрибутивов Linux до сего дня было два знаковых события(если не считать самого факта начала Linux-дистрибуции). Был период «бури инатиска» — рубеж тысячелетий, когда, вслед за первой версией Mandrake(имевшей, как ни странно, номер 5.1), поднялась волна так называемых«дистрибутивов, дружественных к пользователю» (они же — «с человеческимлицом»). И был «год великого перелома» — 2005, когда Ubuntu 5.10 BreezyBadger, став пригодной для применения, в одночасье обрела невероятнуюпопулярность среди применителей всех стран и народов, заставив разработчиковвсех остальных популярных дистрибутивов пересмотреть свою политику в отношенииэтих самых применителей.С тех пор в мире Linux-дистрибуции происходили события более или менеезаурядные. Новостные ленты заполнились сообщениями: вышел релиз W.Wдистрибутива Имя рек с ядром X.XX, KDE Y.Y.Y и GNOME Z.Z.Z, со списком прочихизменений — длинным, но мало чего дающим применителю. Конечно, каждый такойрелиз содержал усовершенствования. Хотя в последние годы первое действие признакомстве со многими из них было: посмотреть — а чего они на этот разполомали?Началось привыкание к заурядности происходящих событий. Настолько сильное,что, когда в последний день весны 2014 года, произошло событие действительнонезаурядное — оно имело все шансы остаться практически незамеченным. А, междутем, по своей значимости оно вполне сопоставимо с выходом Mandrake 5.1 иUbuntu 5.10. Это событие — релиз Mint 17 Qiana в сборке с рабочей средойCinnamon 2.2. О которых и пойдёт речь в дальнейшем — но уже в актуализованномтандеме, появившемся в ноябре 2014 года и включающем Mint 17.1 Rebecca иCinnamon 2.4.Что такое MintПолное имя первого из героев этого цикла — LinuxMint. Однако, поскольку ясно, о дистрибутиве какойоперационной системы идёт речь, первый компонент я в дальнейшем буду опускать.Дистрибутив Mint, начиная с 2011 года, стабильно занимает первое место врейтинге Distrowatch. Конечно, это не значит, чтоон является самым распространённым или самым популярным — рейтинг этот, как ивсе подобные измерители… животов, вещь достаточно условная. Но безусловносвидетельствует о широкой известности дистрибутива в узких кругах применителейLinux. Так что я могу ограничиться очень краткой его характеристикой.Дистрибутив Mint был создан в 2006 году Клементом Лефевром (Clement Lefebvre),который поставил своей целью создание идеального десктопа «для народа» —домашних пользователей и малого бизнеса. Он представлял собой дериват Ubuntu —термины клон или форк в данном случае не применимы. То есть Mint в базовойсвоей части, вплоть до Xorg, основан на кодовой базе Ubuntu, и всесоответствующие пакеты берутся из её репозиториев без всяких изменений. Однакоон имеет и собственный небольшой репозиторий (около 500 пакетов), содержащийдистрибутив-специфические компоненты.Клемент ЛефеврВ сентябре 2010 года было объявлено о выходе другого дистрибутива проекта Mint— Linux Mint Debian Edition (LMDE). Как можно догадаться из его имени, он былоснован на кодовой базе не Ubuntu, а Debian. В качестве таковой выступала еговетка testing, и потому релиз-цикла у LMDE нет — его «плавающие» версиимаркировались годом и месяцем. Впрочем, в этом цикле речи о них не будет —этот дистрибутив заслуживает отдельного рассказа, время для которого ещё ненаступило.Немного историиЗавязка сюжета относится к 2011 году. До этого момента в качестве рабочегоокружения в Mint использовался GNOME текущей версии — той же, что в базовойUbuntu. Правда, GNOME был в нём главным, но не единственным десктопом. Чуть лине со дня основания Mint существовала и его сборка с KDE, позднее к нейприсоединились варианты с рабочими средами Xfce (2007 год) и LXDE (2010 год),на протяжении 2008-2010 годов существовал даже вариант с оконным менеджеромFluxbox. Однако они имели не вполне официальный статус, и появлялись, какправило, несколько позже сборок «генеральной линии». И иногда пропадали сгоризонта вообще, как случилось с редакциями LXDE и Fluxbox.Но весной 2011 года, с одной стороны, Ubuntu переходит на среду Unity, сдругой — появляется релиз GNOME 3 с оболочкой GNOME Shell, поддержка же GNOME2 разработчиками этого десктопа официально прекращается.Оба новых десктопа, по ряду причин, оказались для разработчиков Mintнеприемлемыми. И потому они, с одной стороны, включили в свой дистрибутивдесктоп MATE, а с другой — занялись разработкой новой оболочки для GNOME 3,которая в декабре 2011 года была анонсирована под именем Cinnamon. И это —второй герой настоящего цикла.Возвращаясь к современностиОднако надо возвратиться к первому герою и обрисовать современное положениедел. Вышедший 31 мая релиз 17 Qiana был представлен, как уже говорилось,основными десктопными редакциями с Cinnamon и MATE в качестве рабочих сред, всборках для 32- 64-разрядных архитектур.Постепенно к ним присоединялись другие варианты дистрибутива. Так, обе базовыередакции получили так называемые образы nocodecs и oem. Как нетруднодогадаться, первые предназначены для стран, признающих патенты на алгоритмы,вторые — для предустановки на новые компьютеры. А затем к базовым редакциямприсоединились редакции с рабочими средами KDE и Xfce.С появлением в ноябре 2014 года релиза 17.1 Rebecca перечисленные образысменились одноимёнными редакциями с актуальными на данный момент рабочимисредами Cinnamon и MATE, к которым опять-таки чуть позже присоединились KDE- иXfce-сборки. Выход же второй версии дистрибутива LMDE запланирован на март2015 года.Все перечисленные варианты представляют Live-образы, которые могут бытьзаписаны либо на DVD-диски (объём их 1,3-1,4 ГБ), либо на твердотельныеносители типа USB Flash или SD-карт. Во втором случае это можно сделать испециализированными утилитами типа UNetbootin, и прямой командой dd. Программаинсталляции запускается из Live-режима любого диска, альтернативных, то есть«чисто установочных», вариантов ни для одной редакции Mint не предусмотрено.Скачать образы можно по ссылкам с официального сайта проекта, где приведён списокмногочисленных зеркал, физически находящихся в разных странах. В российскихусловиях целесообразно обратиться на зеркало Яндекса.На этом мы временно попрощаемся с дистрибутивом Mint. Следующий очерк будетпосвящён общему знакомству со второй героиней нашего повествования — одной издвух основных его рабочих сред, которая носит имя Cinnamon."
},




{
"title": "Введение в Cinnamon",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca030_cinnamon_intro.html",
"summary": "",
"body": "Здесь будет рассказано о интегрированной рабочей среде Cinnamon — её истории,особенностях, распространении и поддержке в других дистрибутивах.ИсторияCinnamon — самая молодая из «уже действующих» интегрированных рабочих сред(иначе — декстопов): проект был анонсирован 20 декабря 2011 года, а уже 23декабря он стал доступен для скачивания, и сразу в виде релиза 1.1.2 — версиис меньшими номерами предназначались только для тестирования.Далее развитие проекта происходило стремительно: 23 января следующего годапоявляется релиз 1.3, в середине марта — 1.4, а затем, в сентябре — релиз 1.6.После чего устанавливается полугодовой релиз-цикл — релиз 1.8 выходит в свет 5мая 2013 года, после серии релизов корректирующих. В октябре того же годапоявляется релиз 2.0, в апреле 2014 года — релиз 2.2. И, наконец, герой нашегорассказа, релиз 2.4, увидел свет 1 ноября 2014 года.Все релизы среды опережали версии Mint, для которых они предназначались,примерно на месяц — для дополнительного тестирования среды силами энтузиастови притирки её к целевому дистрибутиву. Что, как показала практика, даваловесьма положительный результат. О чём могу свидетельствовать по собственномуопыту для версий Cinnamon 2.2 и 2.4: в релизы Mint 17 и 17.1, соответственно,они были включены в существенно доработанном виде по сравнению с первоначальнопредставленными сборками.Смена версий Cinnamon отражает специфичность его судьбы. Что же происходилопри этом? В предыдущем очерке упоминалось, что история этого десктопа началасьс появлением GNOME 3. Говорить о кипении страстей, связанных с этим событием,здесь не уместно. Достаточно сказать, что для многих применителей рядадистрибутивов, включавших GNOME 2 в качестве штатного десктопа, его«осовремененная» версия, в частности, «очень прогрессивная» оболочка GNOMEShell, оказалась неприемлемой.В частности, Mint был очень крепко связан с десктопом GNOME 2. Однако GNOME 3,особенно в своём первозданном виде, в концепцию его развития не вписывался, аоснова его предшественника, библиотека Gtk 2, перестала поддерживатьсяразработчиками. Ситуация требовала кардинального решения.Первое решение носило косметический характер. Это был набор MGSE (Mint GNOMEShell Extensions), объединяющий дополнения к GNOME Shell, которые моглиобеспечить не только его традиционный интерфейс, но и восполнить недостающийфункционал за счёт внешних модулей, таких, как панель Bottompanel, системапереключения между окнами Windowlist и меню приложений Menu. Результатом сталвыход в ноябре 2011 года релиза Mint 12 Lisa, включавшего в качестве десктопапо умолчанию GNOME 3 с MGSE.Однако, видимо, майнтайнерам Mint изначально было ясно, что MGSE — не более,чем паллиатив, и потому, с одной стороны, включили в свой дистрибутивальтернативный десктоп — MATE (первыми среди майнтайнеров распространённыхдистрибутивов). А с другой стороны, можно догадаться, что где-то за кадромКлемент Лефевр (Clement Lefebvre), основатель и основной майнтайнердистрибутива, уже ковал основу совершенно новой оболочки для GNOME 3. Котораястала доступной буквально через месяц после выхода Mint 12 Lisa и получила имяCinnamon.Отступление. Словом cinnamon, восходящим к латыни, в английском языкеназывают, во-первых, коричное дерево, коричник цейлонский (Cinnamomumzeylanicum) — вечнозелёное растение семейства лавровых. Второе его значение —корица, название пряности, изготовляемой из коры этого дерева. Наконец, словоcinnamon применяется и для именования коричного масла, добываемого из листьевкоричника, и используемого в медицине, парфюмерии и косметике.Основу Cinnamon&#39;а составил оконный менеджер Muffin — форк аналогичнойпрограммы Mutter из GNOME 3. Главное отличие новой оболочки от связки GNOME 3и MGSE состояло в том, функционал внешних расширений последнего был включённепосредственно в её состав. Это предоставило средства управлениявзаимодействием между дополнительными функциями и определения порядка ихзагрузки. В результате были реализованы добавление пиктограмм в областьуведомлений, система уведомлений в стиле GNOME 2, возможность измененияпозиции панели и и её автоматического скрытия.После серии основных и корректирующих релизов, стремительно следующих друг задругим, Cinnamon 1.4 UP1, появившийся 14 мая 2012 года, был включён в качествештатного десктопа в Mint 13 Maya, анонсированный десять дней спустя. С тех порвыход его версий и стал привязан к релиз-циклу этого дистрибутива.Всё это время Cinnamon представлял собой просто оболочку к GNOME 3,надстраивающую «форкнутый» менеджер окон и замещающую собой его штатный GNOMEShell. Он включал все базовые приложения GNOME 3 — терминал, файловыйменеджер, текстовый редактор — в неизменном виде. Однако во время подготовкирелиза GNOME 3.6, в котором предполагалось существенное ограничениефункционала файлового менеджера Nautilus, разработчики Cinnamon начали работынад форком его версии 3.4, назвав её Nemo. Который и попал в релиз Mint 14Nadia, хотя сначала в качестве альтернативного. Но уже в версии Cinnamon 1.8.Xон был интегрирован с этой средой. Кроме того, в этой версии отказались отЦентра управления GNOME 3.Версии Cinnamon 1.8 суждено было стать последним «чистым» форком GNOME 3 — вэто же время полным ходом шла подготовка релиза 2.0. Суть её заключалась вполной замене базовых компонентов GNOME 3 собственными аналогами. То есть — всоздании полностью обособленного окружения, не пересекающегося с GNOME 3 и несвязанного с ним внешними зависимостями. В результате чего Cinnamon изоболочки для GNOME, вроде GNOME Shell и Unity, превращался в полноценноерабочее окружение. Итог этой деятельности был вынесен на суд общественности 10октября 2013 года, в виде релиза 2.0.ОсобенностиТак каковы же особенности нового десктопа, приобретённые им в версии 2.0 иполучившие дальнейшее развитие в версиях последующих? Важнейших — три.Первая — в Cinnamon гармонично сочетаются старые добрые элементы управления,такие, как главное меню в стиле кнопки Пуск, и элементы модерна, стольпривлекающие в Unity, такие, как строка поиска, подобная Dash — но безизлишеств последнего, то есть без средств поиска в Интернете всякого рода«парнухи».Вторая особенность — достигнутая в Cinnamon гармония между простотойконфигурирования и богатством возможностей последнего. Если настройки в KDE,при их изобилии, приобретают всё более необозримый вид, а в GNOME 3, напротивразубоживаются, в нашем десктопе они почти столь же просты, как в Xfce, ипочти столь же изобильны, как в KDE. И, в отличие от Ubuntu, выполняютсяисключительно штатными средствами, а не бесчисленными твикерами сполуофициальным и вообще неофициальным статусом.Третья особенность — аскетизм Cinnamon в отношении штатных приложений. Всуществующем виде к таковым можно отнести только файловый менеджер Nemo.Обычно богатство приложений считается достоинством интегрированных сред (на тоони и зовутся интегрированными). И бедность Cinnamon в этом плане можно былобы отнести к числу её недостатков. Если бы не оборотная сторона медали —отсутствие приложений в штате среды позволяет легко и без избыточностиподобрать оптимальный набор рабочих инструментов «для себя».Наконец, весь традиционализм Cinnamon&#39;а покоится на весьма современном базисев виде библиотек Gtk+ 3, что должно обеспечить спокойное развитие этогодесктопа в обозримом будущем. При этом сохраняется и совместимость сприложениями на основе Gtk+ 2, до сих пор широко распространёнными и неимеющими адекватных аналогов.РаспространениеТем не менее, несмотря на многочисленные достоинства, десктоп Cinnamon долгоне получал широкого распространения в дистрибутивах Linux. И после знакомствас его историей легко понять, почему. В сущности, модель разработки егооказалась противоположно направленной по сравнению со всеми остальнымиинтегрированными средами. Если KDE, Xfce, GNOME, а позднее LXDE и Razot-qtсоздавались командами разработчиков, более или менее независимыми отмайнтайнеров отдельных дистрибутивов, и лишь потом начинали использоватьсяпоследними в своих сборках, если MATE представлял собой попытку сохранитьнаработки GNOME 2, то Cinnamon с первых дней своего существования выглядел«привязанным» к прародительскому Mint. Почти так же, как это имеет место дляUbuntu и Unity — или, по крайней мере, как это воспринимается для последнейпары так называемой общественностью.На самом деле эта «привязка» была кажущейся, хотя команды разработчиков Mint иCinnamon действительно были множествами сильно пересекающимися. И политикаразработчиков этого десктопа не требует от сторонних разработчиков, скажем,передачи им имущественных прав на свою продукцию, как это практикует фирмаCanonical при приёме патчей для Ubuntu и Unity. Однако можно предполагать, чтомайнтайнеры большинства дистрибутивов отнеслись к Cinnamon настороженно. Темне менее, некоторые из них поддержали нашу героиню.ПоддержкаЕсли через поиск Distrowatch попытаться найти дистрибутивы, поддерживающие Cinnamon,получится список из 16, на момент сочинения этих строк, позиций. Он не вполнесоответствует действительности — с одной стороны, на официальных сайтахнекоторых проектов явных упоминаний о поддержке этого десктопа необнаруживается, с другой — некоторые дистрибутивы, в которых он есть заведомо(например, openSUSE), в нём отсутствуют. Однако, с учётом этого и сисключением явной экзотики из Южной Африки, Андалузии или Непала, оказывается,что Cinnamon поддерживается в десятке распространённых дисрибутивов, средикоторых:Fedora и её клон — Korora; Sabayon — дружественный к пользователю клон Gentoo; Archlinux и его клон Manjaro; openSUSE, где он присутствует в полуофициальном (Semi official) репозитории; siduction — дистрибутив, основанный на unstable-ветке Debian; PC-BSD, которая, конечно, не Linux, но Cinnamon поддерживает на стадии установки. Я перечислил только те дистрибутивы, в которых поддержка Cinnamon может бытьзадействована на стадии их установки, и реализацию её проверял лично. Крометого, Cinnamon нынче можно найти в портах FreeBSD и пакетах DragonFly, втестовоой ветке Debian, а главное — в ppa-репозиториях Ubuntu. До недавнеговремени в последних она поддерживалась Гвендалем Ле Бианном (Gwendal LeBihan). И, хотя весной 2014 года он отказался от сборки стабильной ветки этойсреды, ограничившись экспериментальными «ночными», эстафета была немедленноподхвачена другими майнтайнерами.Как я уже сказал, большая часть перечисленных выше систем проверялась мной напредмет поддержки Cinnamon собственноручно. И этот личный опыт показывал, чтодо недавнего времени качество таковой у всех представителей списка (кромеUbuntu) оставляло желать лучшего. Это касалось мелких, но часто существенныхдля применителях деталей, таких, как настройка раскладок клавиатуры и ихпереключателей.Однако буквально в последние месяцы, после выхода Cinnamon 2.4, ситуацияизменилась кардинальным образом. И теперь этот десктоп безукоризненноподдерживается в большинстве дистрибутивов первого эшелона — в Archlinux&#39;е иManjaro, в openSUSE и Fedora, по прежнему хорошо — в Ubuntu, с оговорками насчёт отставания версии — в Debian testing (опять же, говорю только о тех, вкоторых проверял сам).Однако по прежнему наиболее эффективно Cinnamon поддерживается в Mint — засчёт интеграции его с дистрибутив-специфическим системным инструментариемпоследнего. Подобно тому, как испокон веков KDE было лучше всего интегрированос openSUSE, GNOME органично срастался с Fedora, а Xfce был «роднее» лёгкимклонам Slackware (таким, как Zenwalk и Salix). Так что самый простой способознакомиться со средой Cinnamon во всёй её красе — установка соответствующейредакции Mint 17.1 Rebecca, о чём и пойдёт речь в следующем очерке."
},




{
"title": "Linux Mint: установка",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca040_linux_mint_installation.html",
"summary": "",
"body": "Сравнение инсталлятора дистрибутива с театральной вешалкой настолько старо,что никто уже не помнит автора (вашему покорному слуге почему-то кажется, чтоэто был именно он). И за минувшие пятнадцать лет оно не столько дажезатёрлось, сколько потеряло силу. В наши дни любой дистрибутив, претендующийна внимание так называемых конечных пользователей, располагает удобной, болееили менее функциональной программой установки самого себя, иногда дажекрасивой. Тем более что удачные решения в этой области имеют обыкновениерасползаться по всяким клонам и ремиксам.Именно так случилось некогда с инсталлятором Ubuntu — десять лет назад егоустановка в пять кликов сыграла не последнюю роль и в распространении этогодистрибутива по пользовательским десктопам, и в образовании многочисленныхпрямых, косвенных и откровенно примазавшихся родственников, вплоть до«дистрибутивов с нескучными обоями».В числе родственников... нет, не примазавшихся, а настоящих, но пошедшихдругим путём, был и дистрибутив Mint. Сейчас не время обсуждать еговзаимоотношения с прародительской Ububtu, но программу установки онунаследовал от неё практически без изменений. По крайней мере, до недавнеговремени макроскопических различий в инсталляторах этих систем не наблюдалось.Честно говоря, их не наблюдается и сейчас, с выходом версии Mint 17, а затем иMint 17.1 — формально отличий в установке с Ubuntu 14.04 нет. Так что о чёмтут говорить, спросите вы меня? Отвечу: говорить действительно не о чем — этонужно видеть. Точнее, делать своими руками — и наблюдать за результатом. Ибодаже скриншоты, которыми я на этой странице практически и ограничусь, не всилах передать того ощущения лёгкости и плавности, которое испытывает истинныйприменитель при установке этого дистрибутива.Итак, установка Mint&#39;а запускается из Live-режима его работы, являющегосяследствием загрузки с соответствующего носителя — DVD или, чтопредпочтительно, флешки (или SD-карты). Кстати, не обязательно слушать того,кто будет убеждать вас закатать iso-образ на твердотельный носитель с помощьювсяких специальных утилит. С этой задачей прекрасно справляется такая команда:# dd if=path3/linuxmint-17.1-cinnamon-64bit.iso of=/dev/sd? bs=8MСимвол решётки тут символизирует, что она должна быть дана от имениадминистратора (то есть в Ubuntu и её клонах — в форме$ sudo dd...и так далее. Имя входящего файла образа выбрано так потому, что дальнейшийрассказ у меня пойдёт исключительно о Cinnamon-редакции соответствующегорелиза. Хотя, надо отметить, что установка MATE- и Xfce-редакций ничем неотличается, только инсталлятор редакции с KDE имеет некоторую специфику,Вместо знака вопроса следует подставить литеру своего твердотельногоустройства — подчёркиваю, именно устройства целиком, а не раздела на нём. Ну азначение bs (размер блока записи) взято с потолка: если не задать этотпараметр, запись будет идти блоками по 512 байт, и это будет очень медленно ипечально.Конечно, использование для записи iso-образа на флешку/карточку всякого родаграфических утилит тоже не возбраняется. Важно только помнить, что многие изних — дистрибутив-специфичны. Этому вопросу на Блогосайте посвященаспециальная статья: Дистро в твёрдом теле.Так или иначе, но флешка будет записана и с неё произойдёт загрузка системы —автоматически, если в ходе её ничего не делать, или, если в течении 10 секунднажать любую клавишу, из такого меню:    После чего мы оказываемся в live-среде Cinnamon — пора бросить на неё взгляд,пока беглый:  Вдаваться в её рассмотрение сейчас не стоит — для этого у нас будет многовремени после установки, к которой и приступаем. Как нетрудно догадаться,запуск инсталлятора осуществляется щелчком на пиктограмме с соответствующейподписью — Install Linux Mint. И начинается процесс с предложения выбрать языкустановки — по умолчанию английский:  Однако, если у вас нет непреодолимого отвращения к языку родных осин, но естьжелание без лишних трудозатрат иметь корректно локализованную систему,выбирайте русский, не пожалеете. Это будет язык не только интерфейсаинсталлятора, но и грядущей инсталлированной системы:    Русификация Cinnamon до недавнего времени была далека от идеала, и со смесьюнижегородского с оксфордским приходилось сталкиваться сталкиваться довольночасто. Однако в версии 2.4 ситуация резко улучшилась, и языковый микст можноувидеть только в единичных случаях.Далее выдвигаются претензии к объёму свободного места и подключению кИнтернету — приведённой цифрой первого и потребностью во втором нынче испугатьтрудно:    Следующий этап — разметка диска. Здесь надо действовать по амбициям иамунициям, так что просто прокомментирую пукты соответствующего меню:  Очевидно, что отмеченный по умолчанию пункт Стереть диск и установить LinuxMint подходит только для установки на «чистый» носитель или такой, содержимымкоторого можно безболезненно пожертвовать. Причём именно всего устройства, ане какого-либо его раздела, ибо в этом варианте диск будет переразмеченполностью, начиная с таблицы разделов.Об установке системы на шифрованный раздел (пункт второй) сказать ничего немогу, так как никогда не пробовал (и сомневаюсь в необходимости в обычных«настольных» условиях). Установка с использованием LVM (Logical Volume Manager)показалась мне не очень прозрачной, и я её тоже не опробовал. Но современем расскажу, как задействовать LVM в уже инсталлированной системе. Ипотому я всегда выбираю Другой вариант: он подразумевает разметку дискавручную. Как её выполнить — говорено и переговорено на бесчисленных ресурсах вСети: тут всё зависит от ситуации, потребностей и возможностей. Так что простоприведу несколько скриншотов, иллюстрирующих самый простой случай — разметкуодиночного «чистого» на два раздела — корневой и под будущий домашний каталог(каковой, кстати, в умолчальном первом варианте не создаётся).Итак, перед нами чистый, неразмеченный диск:  Можно видеть, что ни одна из кнопок манипуляции разделами (+, -, Change) неактивизирована, ибо диск наш лишён таблицы разделов. Которую и надо в первуюочередь создать, нажав соответствующую кнопку. Ответом будет предупреждение отом, что все ранее существовавшие разделы будут уничтожены. Поскольку их всёравно нет, соглашаемся на это:    В результате будет создана таблица разделов в стиле MSDOS. Создание GPT-разметки не предусмотрено, но если диск был предварительно размечен в этомстиле — он прекрасно воспримется инсталлятором.Теперь активизируется кнопка с плюсиком — очевидно, что она служит длясоздания разделов. Однако, прежде чем заняться этим делом, бросим взгляд настроку Устройство для установки системного загрузчика, каковым на скриншотевыступает /dev/sda. То есть загрузчик будет установлен в MBR первого диска,что для «чистой» однодисковой (и к тому же виртуальной) конфигурации вполнеестественно. А вот в случае какой-либо уже установленной системы, особенно приналичии двух и более дисков, этот момент требует внимания.Дело, однако, в том, что первый диск (то есть устройство /dev/sda) будет поумолчанию целевым для установки загрузчика вне зависимости от того, на какойдиск и или раздел устанавливается Mint, что в большинстве таких случаев нетолько не нужно, но и прямо вредит здоровью сосуществующих систем. И потомунадо ни в коем случае не забыть выбрать из выпадающего меню нужное устройство— MBR диска или PBR раздела, целевых при установке Mint.К сожалению, вообще отказаться от установки загрузчика нельзя, даже когда онзаведомо лишний, и Mint предполагается загружать через загрузчик какой-либоиной системы. Эта багофича унаследована от Ubuntu, где существует испоконвеков. Но можно обмануть установщик, подсунув ему в качестве целевого MBRкакого-либо «левого» устройства, например, старой ненужной флешки или SD-карты, каковые потом просто извлекаются, как-будто так и было.Вот теперь со спокойной душой можно приступать к созданию разделов, нажавкнопку с плюсиком. Проделываем эту процедуру сначала для корневого раздела:А затем для раздела под будущий каталог /home:    И в результате получаем вот такую картину:  По умолчанию в обоих случаях предлагается файловая система Ext4. Если онапочему-либо не устраивает — можно ознакомиться со списком доступных, онвключает все нативные файловые системы Linux&#39;а, кроме ReiserFS:  Должен заметить, что на стадии установки в Mint не только нельзя создать,скажем, программный RAID (в отличие от Ubuntu, в которой это ужепредусмотрено): нельзя даже установить систему на softRAID, созданныйзаблаговременно, инсталлятор его просто не увидит. Впрочем, в дальнейшем,после установки, ни подключить существующий RAID, ни слздать его заново трудане составит, о чём будет говориться в соответствующем очерке.Как можно было видеть, в приведённой схеме разметки отсутствует разделподкачки. О чём и будет сообщено на следующей стадии:    Нужен такой или нет — вопрос спорный и многократно обсуждавшийся. На мойвзгляд, при памяти от 4 ГБ в большинстве случаев, кроме некоторых специальных,не нужен. Так что можно продолжать — это действие вызовет последнее китайскоепредупреждение:    Смысл его в русском переводе может показаться не вполне внятым. Он сводится ктому, что все действия по разметке диска будут выполнены только сейчас, нопосле этого возврат к прошлому станет невозможным — до сих пор установку можнобыло в любой момент прервать, сохранив исходное состояние диска.Поскольку бояться нам нечего, нажимаем кнопку Продолжить. И, после некотороговремени, требующегося на разметку и создание файловых систем, совершаемпоследние манипуляции — настройку часов, клавиатуры и созданиепользовательского аккаунта.С выбором часового пояса всё понятно без комментариев — при выборе русскогоязыка инсталляции он будет московским и подразумевать установку «железных»часов по UTC:    Так что обитателям более иных городов и весей нашей необъятной Родины следуетне забыть внести нужные изменения — это можно сделать, просто ткнув курсороммыши в район Петропавловска Камчатского (Улан-Удэ, Новосибирска — нужноедописать).А вот вопрос с раскладкой внимания заслуживает: выбранная сейчас, онаостанется и в инсталлированной системе. Опять же при выборе русского языкаинсталлятора по умолчанию и раскладка клавиатуры предлагается русская — вданном случае под этим понимается вариант winkeys:    Он устроит большинство применителей — но не таких старых «печатно-машинистов»,как автор этих строк. Что же, никто не запрещает выбрать вариант Typewriter Legacy — это раскладка советских пишущих машинок, почему-то объявленнаяустаревшей. И даже опробовать его в деле, переключаясь с латиницы на кириллицучерез Alt+Shift:    Смены переключателя раскладок на стадии установки не предусмотрено — её можнобудет поменять потом, средствами Cinnamon. Зато установленная сейчас раскладкасохранится после установки не только в Иксах, но и в «голой» консоли. Причёмдаже такая нетипичная, как при моём выборе. Это чуть ли не уникальный случай —в других дистрибутивах для консоли раскладку Typewriter Legacy мне приходилосьизготавливать самому.В деле создания пользовательского аккаунта всё очевидно. Замечу только, чтораскрывать своё подлинное имя здесь не обязательно — это поле можно простооставить пустым. А вот задать имя компьютера необходимо — без этого неактивизируется кнопка Продолжить. Впрочем, в большинстве случаев оно можетбыть произвольным. Ну а требовать ли от самого себя пароль для входа в системуили нет — дело чести, подвига и геройства личной паранойи:    После этого начинается собственно установка, то есть перенос системы нацелевой носитель:  В Ubuntu это делается весьма неторопливо. В инсталляторе же Mint едвауспеваешь заварить себе кофий или выкурить сигарету, как обнаруживаешь наэкране вот такое сообщение:  После которого только и остаётся, что перезагрузиться. Правда, после этогобудет ещё одно сообщение:  Если установка проводилась с DVD-диска, он будет извлечён из приводаавтоматически, и Enter можно нажимать сразу. Если с флешки или SD-карты —соответствующее устройство желательно предварительно удалить. Ну а чтополучилось в результате инсталляции — будет рассказано в следующем очерке."
},




{
"title": "Mint и Cinnamon: обзор среды",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca050_mint_and_cinnamon_obzor.html",
"summary": "",
"body": "Предыдущий очерк мы завершили тем, что после удачной установки отправилимашину на перезагрузку. После которой, проскочив меню GRUB&#39;а (в случае однойсистемы по умолчанию оно не выводится), оказываемся в дисплейном менеджере MDMс предложением авторизоваться:  По принятии этого предложения перед нами предстаёт рабочий стол Cinnamon сэкраном приветствия:    И о дисплейном менеджере, и об экране приветствия случай поговорить ещё будет.Нынешний эе очерк будет посвящён интерфейсу рабочего стола Cinnamon, так какименно там в основном будет проходить деятельность применителя, избравшегосоответствующую редакцию дистрибутива Mint.Cinnamon. Общий видПри первом своём запуске Cinnamon выглядит более чем традиционно – перед намисамый обычный рабочий стол с управляющей панелью, на которой имеется кнопка сподписью Меню (или Menu, в зависимости от локализации):    В отличие от GNOME Shell&#39;а или Unity, здесь сразу ясно, что делать дальше. Во-первых, можно щёлкнуть правой кнопкой мыши по рабочему столу, чтобы увидетьего контекстное меню: Здесь почти всё понятно без комментариев, пару слов можно сказать только продва пункта:Добавить десклеты – добавление на рабочий стол мини-приложений (подробнее об этом будет сказано в следующем очерке); Открыть как администратор – вызов, после ввода пароля, файлового менеджера Nemo с правами суперпользователя. Во-вторых, щёлкнув правой же кнопкой мыши по свободному полю управляющейпанели, можно заняться её настройками (о чём будет разговор в соответствующемочерке): Или, уже с помощью левой кнопки, вызвать одно из приложений, пиктограммызапуска которых уже имеются на панели. По умолчанию их не густо – браузерFirefox, унаследованный от GNOME терминал и файловый менеджер Nemo: Но пополнить панель иконками приложений первой необходимости труда не составит– и со временем я расскажу, как.Наконец, в-третьих, можно обратиться к главному меню Cinnamon для знакомствасо всем изобилием установленного софта:    Но обзор штатных приложений дистрибутива будет дан в соответствующем очерке.Как и во всех современных рабочих средах, в Cinnamon&#39;е можно задействоватьнесколько виртуальных рабочих столов. В терминах этой среды они называютсярабочими областями (Workspaces), и по умолчанию их два. Переключение междурабочими областями – комбинациями клавиш Control+Alt+Right/Left.Есть и другие способы переключения между рабочими областями, и количество ихможно увеличить до любого разумного предела. Но это относится уже к категориинастроек, которым будет посвящён отдельный очерк.Управляющая панельЕсли на рабочем столе (точнее, в рабочих его областях) происходят основныесобытия, то управление этими событиями в значительной мере осуществляется спанели – в других средах её часто называют главной, или управляющей. Но вCinnamon её принято называть без определений, поскольку здесь она обычноимеется в единственном экземпляре. Хотя в принципе в нём может быть включена ивторая панель, о чём речь пойдёт в очерке о настройках.Положение панели по умолчанию – вдоль нижней части экрана, хотя её можнопереместить и наверх. И разделяется она на следующие части (слева направо):кнопка главного меню (опять же – обычно просто Меню);область запуска приложений (Panel Launcher) с пиктограммами – как уже было сказано, по умолчанию их всего три;область открытых приложений (Window list); область системных сообщений (Notifications); системный лоток (System Tray), куда помещаются пиктограммы «перманентно работающих» приложений; несколько пиктограмм разного назначения – список открытых окон (Windows Quick List) и подключаемых накопителей (Removable Drives), модуль сетевых соединений, регулятор громкости, часы, индикатор раскладки клавиатуры, пиктограмма менеджера обновлений.  Кроме того, имеется «пользовательская кнопка» – она показывает сведения отекущем аккаунте, вызывает системные настройки, через неё блокируется экран ипереключаются пользователи, осуществляется вход в так называемый «гостевой»сеанс, а также выполняется завершение сеанса работы, перезагрузка машины и еёвыключение: Все области и кнопки панели представляют собой так называемые апплеты – мелкиепрограммки, не способные к самостоятельному функционированию. Некоторые изэтих апплетов (Panel Launcher, Window list, System Tray) представляют собойконтейнеры для помещёния в них других пиктограмм (запуска, открытых окон, итак далее), другие же существуют как бы сами по себе.Апплеты могут добавляться на панель и удаляться с неё. Содержимое апплетов-контейнеров добавляется или автоматически (System Tray, Window list), иливручную (Panel Launcher). Удаление апплетов-контейнеров приводит кисчезновению всего их содержимого. Элементы из лаунчера можно удалять поодному, содержимое лотка и области приложений – вместе с закрытиемсоответствующих программ.Главное менюЦентральным (хотя и левым крайним) элементом панели является, безусловно,главное меню, с которым и настало время ознакомиться подробнее. На первыйвзгляд оно ничем не отличается от обычных менюшек «пускового» типа, с ихстрашной многоступенчатой иерархией. Однако если вглядеться в соответствующийскриншот ещё раз – различия обнаруживаются, и весьма существенные:  Перво-наперво, обратим внимание на колонку пиктограмм вдоль левого края поляменю:   Набор их в сборке Cinnamon для Mint включает иконки для запуска:браузера Firefox; менеджера программ mintinstall; Центра управления (он же – Системные настройки); терминала; файлового менеджера Nemo. Кроме того, имеются значки блокировки экрана, выхода из сеанса и завершенияработы. Конечно, к последним действиям можно получить доступ и через UserApplet панели, но там его ещё надо разглядеть и до действий докопаться, а тутони всегда на виду.Не менее примечательна поисковая строка в верхней части экрана – онапредназначена для поиска приложений. Но не простого, а золотого инкрементного.То есть, введя в ней последовательность символов libre, мы получим списоктолько тех пунктов меню, которые её содержат, то есть компонентов LibreOffice:    То есть строка поиска в меню Cinnamon тихо и скромно, без шума и пыливыполняет ту же функцию, что и пресловутый Dash в Unity (и его аналог в GNOME3). Правда, с её помощью нельзя устанавливать программы или искать «парнуху» вИнтернете – но не больно-то и хотелось.А вот искать по русским словам – с некоторыми ограничениями можно. Введя,например, слово редактор, мы увидим приложения, содержащие его в своём имени:    А на слово текст ответом будет список приложений, содержащих его и в описании:    На мой взгляд, сказанного уже достаточно, чтобы проникнуться величием средыCinnamon. Однако это ещё не всё – оно проявляется и в управлении окнами.Однако прежде чем говорить на эту тему – остановимся на вопросе, как эти окнаоткрывать.Вызов приложенийОткрываются окна обычно вместе с запущенными в них приложениями. Способов жезапуска последних в Cinnamon, как и во всех современных десктопах, несколько.Первый, наиболее универсальный – запуск из командной строки терминала путёмввода соответствующей команды. Однако обычно полноразмерное терминальное окноиспользовать для этого не целесообразно, его вполне можно заменить панельюмини-терминала – она вызывается обычной для всех десктопов комбинацией клавишAlt+2: До некоторого времени панель мини-терминала в Cinnamon не блисталафункциональностью – в ней не было ни автоподолнения, ни истории команд,имелась только возможность ввести команду руками или вставить её из буфера.Однако в Cinnamon 2.6 все эти прелести появились. Историю команд можно, как ив шелле, просмотреть с помощью стрелок Up и Down. И автодополнение командыпроисходит после набора первых трёх символов её имени, в случае альтернативвыводя все доступные варианты: Правда, при вызове панели минитерминала блокируются как любые любые действиямышью, так и ввод с клавиатуры. Открывается она всегда по центру, иперемещёнию не поддаётся. Так что пользоваться этой панелью не всегда удобно.Однако её возможности сполна, а то и с лихвой, заменяются функциями строкиинкрементного поиска в главном меню, о которой только что говорилось. Именноона становится основным инструментом запуска приложений для тех применителей,которым, как автору этих строк, проще набрать несколько символов из именипрограммы, нежели, подобно Баяну, «мысью рыскать» в её поисках по менюшномудреву. Тем более, что привычные программы, вызываемые давно памятнымикомандами, в меню, тем более русифицированном, могут носить самые неожиданныеимена, и потому опознаваться с трудом.Сразу по вызове главного меню мышью или хоткеем (в Cinnamon, как и в Unity,для этого по умолчанию зарезервирована левая win-клавиша, она же Super_L),строка поиска находится в фокусе ввода, и можно начинать набор имениприложения. Только нужно помнить про раскладку клавиатуры: как бы ни былонастроено её наследование (о чём речь пойдёт в одном из следующих очерков), вэтой строке она всегда будет наследоваться от раскладки последнего активногоокна, а не от раскладки по умолчанию.Разумеется, для запуска приложений можно пользоваться и главным менюнепосредственно, тем более что некоторые из них (браузер, терминал, Центруправления, файловый менеджер), как только что говорилось, вынесены в нём наотдельную панель в виде кнопок быстрого запуска. А вот остальные программы вменю уже надо поискать – тем более что, повторяю, там они могут именоватьсявесьма причудливо.Благо, пиктограммы наиболее востребованных приложений из меню можно поместитьв Launcher на главной панели, на рабочий стол или в пункт Избранное. Для этогодостаточно щёлкнуть правой кнопкой на имени нужной программы и из контекстногоменю выбрать требуемый пункт:    Кроме того, иконки приложений можно просто перетаскивать мышью из меню вLauncher. Причём – сразу в желаемое его место, тогда как при автоматическомпомещёнии иконок они попадают в его конец, и их перетасовка потребуетдополнительных телодвижений.Как только что было сказано, пиктограммы запуска приложений можно поместить ина рабочий стол, и запускать их оттуда. Однако я этим способом никогда непользуюсь — он кажется мне неудобным, и и рабочего стола у меня обычно невидать за распахнутыми окнами.Вот теперь, разобравшись с запуском приложений и открытием вмещающих их окон,можно переходить и к управлению последними.Управление окнамиВ предыдущем разделе очерка речь шла о способах запуска приложений, в этом жепоговорим о способах управления приложениями, которые уже запущены. Посколькумы (пока ещё) живём в системе, которая официально называется X Window System,то большая часть приложений запускается в её окнах. Так что в основномприменителю придётся иметь дело с ними.Вид окон с запущенными приложениями зависит от темы рабочего стола, стиля окони других индивидуальных настроек. Но по умолчанию они выглядят примерно так:    Управление окнами подразумевает в первую очередь переключение между ними. Чтоможно сделать несколькими способами. Первый, напрашивающийся, щелчком любойкнопкой мыши в области окна. В этом случае окну передаётся фокус и оно, какпринято говорить, «поднимается», то есть оказывается на первом плане. Простоперевод курсора мыши на другое окно переводит его в фокус (то есть оно можетскроллироваться), но не поднимает.Как можно видеть на скриншоте, в одной рабочей области может быть открытонесколько окон, которые могут частично или полностью перекрываться. И тогдауниверсальный универсальный способ переключения между окнами, существующий вовсех графических средах, – комбинация клавиш Alt+Tab. Удержание её в нажатомсостоянии выводит ленту значков открытых окон, с миниатюрой для окнаактивного:    Третий способ переключения между окнами – область Window List на управляющейпанели:  Есть ещё переход в режим масштабирования рабочей области, но по умолчанию этотспособ отключен, поэтому я вернусь к нему чуть позже.Сказанное относится к переключению между окнами, расположенными в однойрабочей области. Но они могут пребывать и в разных областях – как мы помним,по умолчанию их две. И в этом случае один из способов переключения между ними,имеющийся «из коробки» – апплет Windows Quick List (в последних версияхCinnamon он помещён на панели по умолчанию):  Второй же – переход в режим Expo через один из «горячих углов», о чём такжебудет говориться вскоре.Теперь посмотрим, что можно делать с самими окнами. В строке заголовка каждогоокна, кроме самого заголовка, в правой его части можно видеть три управляющиекнопки (слева направо): сворачивания, максимизации/восстановления исходногоразмера, закрытия – назначение их очевидно.Кое-какие манипуляции с окнами можно выполнять и кликами мыши по строкезаголовка. Так, двойной щелчок левой её кнопкой вызывает максимизацию окна,повторение его – восстанавливает исходный размер. Тот же двойной клик, но ужеправой кнопкой сворачивает окно на панель задач. Для средней кнопкипредусмотрен только одинарный клик – он «опускает» окно на задний план.Лишь закрыть окно нельзя кликами мыши по строке заголовка. Но это делается(если не обращаться к штатному меню запущенного в окне приложения) комбинациейклавиш Alt+F4 – подобно Alt+Tab, она также универсальна для почти всехграфических сред (или вообще всех современных?). Кроме того, закрыть окноможно из его собственного меню – оно вызывается щелчком правой кнопки мыши построке заголовка, и содержит такие пункты:  Назначение первых четырёх и последних двух пунктов абсолютно понятно. А вот отёх «средних» пару слов сказать можно. Отметка Закрепить на переднем плане –это запрет перекрытия данного окна другими. А пункты Всегда на видимом рабочемместе и Только на этом рабочем месте (включён по умолчанию) – альтернативны:при включении первого окно будет «кочевать» вслед за перемещёниямипользователя по рабочим областям.Тайлинг оконВсё, что было только что сказано относительно управления окон, не покажетсячем-то необычным применителю любого современного десктопа и приверженцамподавляющего большинства оконных менеджеров. А вот сейчас речь пойдёт о вещиболее неожиданной – о тайлинге окон. Это – та самая вторая особенность (послестроки поиска в меню), которая столь восхитила меня в Cinnamon&#39;е.Для начала – пара слов о том, что такое тайлинг. Он основывается на той жеидее, что и консольная утилита screen или двухпанельные файловые менеджеры –потомки командира Norton&#39;а – расщеплении экрана на ряд независимых областей, вкаждой из которых локализуется окно с запущенным в нём приложением. Этоподобно покрытию пола кафелем (tiling), чем и порождена аллюзия.При этом понятие управления окнами как бы лишается смысла – тайлинговыесистемы управляют не столько окнами, сколько теми самыми областями экрана, вкоторых окна открываются. Области эти (в чём-то они похожи на фреймы, некогдапопулярные среди web-дизайнеров) могут быть статическими, с жёсткоопределёнными размерами, и динамическими, при котором их размеры изменяютсяпри масштабировании окон запущенных в них приложений. В Cinnamon реализованапервая модель.Конечно, тайлингом удивить пользователей менеджеров окон типа Awesomeсотоварищи не легче, чем испугать ежа голой... эээ... спиной. Однако вовремена не очень больших экранов я этой идеей не проникса (парадигма «одноприложение – одна рабочая область» была мне ближе). А ко времени мониторовбольших и широкоэкранных тайлинг подоспел и в десктопах – в Xfce и KDE. Однаков сравнении с Cinnamon&#39;овским тайлинг в них выглядит что плотник супротивстоляра. Ибо предусматривает расщепление экрана только на две области – погоризонтали или по вертикали. В Cinnamon&#39;е же возможности тайлинга намногобогаче.Начать с того, что в Cinnamon&#39;е окна можно «тайлить» не только на поэкрана –например, по вертикали:  Или, если хочется, по горизонтали:  Но есть и «четвертиночный» вариант разбивки экрана:  А подчас даже...получается в ответеДва землекопа и две третиПримерно как на этом скриншоте:    Тайлинг окон не препятствует существованию на его фоне окон обычных:  Вот только, к сожалению, средства «тайлить» окна на произвольные областиэкрана на предусмотрено. Однако и без этого область его использованиядостаточно широка, в чём мы убедимся после рассмотрения средств управлениятайлингом.Управление тайлингомТайлинг окон может выполняться двумя способами – посредством мыши и склавиатуры. Как обычно, первый – легче, то есть «ленивей», второй – быстрее иэффективней. Замечу в скобках: как обычно, это вовсе не означает оценки втерминах товарища Маяковского. Иногда «хорошо» – это лениво развалясь вкресле, елозить мышью по экрану, а иногда – напрягать пальцы рады быстротывыполнения неких действий.Рассмотрим сначала тайлинг мышью, выполняемый над окном с положением иразмерами, соответствующими умолчаниям десктопа:    При подтаскивании окна мышью к верхней границе экрана оно занимает верхнюю жеего половину:  Аналогичное движение к нижней границе экрана разворачивает окно на нижнюю егополовину:    Перемещёние окна к боковой стороне экрана «тайлит» его на левую  или правую половины, в зависимости от стороны «подтаскивания»:    Если передвинуть окно в любой из углов дисплея, оно займёт соответствующую его«четвертинку»:  То есть всё просто, но... Предположим, что при сочинении текста в текстовомредакторе (или word-процессоре) появилось желание параллельно бросить взглядна картину, призванную этот текст иллюстрировать: в этом случае тайлингпосредством мыши потребует отрыва руки от клавиатуры и переноса её на спинугрызуна. И вот тут-то на помощь и придёт тайлинг с клавиатуры, которыйосуществляется комбинацией из двух пальцев – клавиши Super (она же – леваяWin) и одной из стрелок управления курсором.Опять же подвергнем издевательствам исходное окно с умолчальными параметрами.Комбинация Super+Right развернёт её на правую половину экрана, Super+Left –вернёт в исходное состояния. Из которого комбинацией Super+Left оноразвернётся на левую половину, а последующий Super+Right – возвратит взад. Изположения «половинка справа» комбинация Super+Up превратит окно в«четвертинку» в правом верхнем углу, Super+Down – «четвертинку» в правомнижнем.Принцип, я думаю, понятен: Super плюс стрелка в любую сторону – окно насоответствующую половинку экрана, Super плюс стрелка в обратную – возврат висходное положение, Super плюс стрелка из «половинного» состояния – перевод всостояние «четвертиночное». Запомнить это не сложно, навык до рефлекторногоуровня приобретается очень быстро. А как его можно применить на практике –сейчас увидим.Тайлинг на практикеВсё это очень блаародно – вправе сказать читатель, – но в чём преимуществотайловых окон перед обычными? Долгое время ответа на этот вопрос у меня небыло, тем более, что я окнами почти не пользовался: во всё ширь каждогодесктопа у меня было открыто одно приложение. Пока не опробовал тайловый режим– сначала в Xfce 4.10, где он незатейлив, а затем и в среде Cinnamon, вкоторой, как я пытался показать на предыдущих страницах, он куда болееизощрён.Тем не менее, объяснить преимущества тайловых окон над масштабированнымидовольно трудно – это надо попробовать самому и оценить. Для меня оновыразилось в возможности мгновенно перейти от сочинения текста в полноэкранномрежиме к режиму параллельного просмотра текста, иллюстраций к нему, файловойиерархии и так далее. И сделать это лёгким движением даже не руки, а двухпальцев.Причём параллельным просмотром нескольких окон можно не ограничиваться. А,например, перетаскивать мышью или просто копипастить горячими клавишамикартинки из файлового менеджера или вьювера изображений в word-процессор.Аналогичным образом можно перетаскивать из теста документации в команднуюстроку терминала примеры командных конструкций. Или, наоборот, команды илиисходники сценариев – помещать в сочиняемый текст.Конечно, всё это можно сделать и при традиционном расположении окон, но прошуповерить на слово брату незабвенного Голубкова:Так лучше, Лёня.В общем, обращение с содержимым окон становится похожим на работу сдвухпанельными файловыми менеджерами a la Midnight Commander. Или даже счетырёхпанельными: возможно, кое-кому из читателей памятен «пай-мальчик» – PieCommander, незаконный четырёхглазый отпрыск командира Norton&#39;а...Правда, в двух- и тем более в «четырёхплиточной черепице» становитсямучительно больно за бесцельно расходуемое экранное пространство, занятое вкаждом окне строкой меню. И возникает сожаление об отсутствии возможностивстроить его в главную управляющую панель, как это делается по умолчанию вUnity. Но увы – нет в жизни совершенства, ибо нет в Cinnamon такойвозможности. Иначе он безусловно достиг бы высшей степени совершенства, а егоразработчики имели бы полное право впасть в нирвану.Интерфейс Cinnamon: краткий итогВ этом очерке были описаны особенности интерфейса Cinnamon, которыепредставляются мне наиболее существенными. Пора подводить итоги.В своём современном виде Cinnamon наделён всеми функциями, присущими остальнымдесктопам. Причём реализованными если не идеально, то близко к тому. А две изних в сочетании оказываются почти уникальными. Это – строка инкрементногопоиска в меню и развитый тайлинг. Обе они представлены и в Unity, и Xfce, и вKDE. Но в первой среде пресловутый Dash как раз функционально перегружен,предусматривая поиск в Интернете не только всякой ерунды, типа программ ипакетов, но и весьма важной и разнообразной «парнухи». В Xfce строка поиска поменю как раз зарыта в дебрях её минитерминала. Ну а в KDE эта строка естьтолько в «меню современного вида», которое само по себе многим (в том числе иавтору этих строк) представляется неудобным. Что же до тайлинга – как я ужеотметил, его реализация в Cinnamon среди всех десктопов превзойдённа.При этом всё сказанное в этой части касалось особенностей Cinnamon&#39;а поумолчанию. Но особенно ярко они заиграют после соответствующих настроек,которым будут посвящены следующие очерки."
},




{
"title": "Cinnamon и системные настройки",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca060_cinnamon_system_config.html",
"summary": "",
"body": "Следующая серия очерков посвящена описанию способов, как штатных, так и неочень, которые изменяют те умолчания Mint и Cinnamon, что были рассмотрены вочерке предыдущем.Системные настройки: вступлениеПодавляющее большинство настроек в Cinnamon выполняется из панели егоСистемных настроек (cinnamon-settings), именуемых также Центром управления. Сними тесно интегрированы фирменные утилиты Mint, имеющие отношение кконфигурированию системы. Однако они будут предеметом отдельного очерка.Пиктограмма запуска Системных настроек занимает почётное место в левой колонкеглавного меню управляющей панели. Через один-два клика мышью до них можнодобраться и из контекстных меню как самой панели, так и рабочего стола. И припервом запуске выглядит он так:    Ранее Системные настройки имели два режима — нормальный и расширенный, иреликты такого положения можно найти в сетевых материалах. Однако, начиная сCinnamon версии 2.2, эта дискриминация ликвидирована, и расширенный режим сталнормой жизни применителя.Если пролистать окно Системных настроек до конца, можно увидеть, что отдельныееё модули группируются в четыре секции:Оформление Параметры Оборудование Администрирование Далее я последовательно рассмотрю возможности каждого модуля примерно в томпорядке, в котором они следуют в русскоязычном варианте Cinnamon. Отклоняясьот него, когда когда того потребует логика.Секция ОформлениеСекция Оформление включает в себя модули:Темы; Фоновые рисунки; Шрифты; Эффекты. Модуль Темы выглядит таким образом:  Организация его подчёркивает, что стилевое оформление отдельных элементовинтерфейса полностью независимо друг от друга и от темы рабочего стола. Этоможно проиллюстрировать серией скриншотов для стилей рамок окон:  Пиктограмм:  Управляющих кнопок окна:  Указателей мыши:    И, наконец, для собственно тем рабочего стола:  Обращает на себя внимание изобилие расцветок умолчальной темы Mint-X, с однойстороны, и пиктограмм — с другой. Это позволяют комбинировать элементыоформления интерфейса в очень широких пределах, достигая максимальноговизуального эффекта. Что, между прочим, сколько бы ни иронизировали на этутему, имеет практическое значение, особенно для людей с плохим зрением илинарушением цветовосприятия.С помощью кнопки Добавить/удалить темы рабочего стола умолчальную тему Mint-Xможно заменить на одну из предустановленных:  Можно также обратиться к коллекции тем, доступных на сайте специальногосубпроекта — это сначала потребует обновления кешатем, что может занять немало времени:  Но будет вознаграждено обильным уловом:    Правда, перепробовав немало тем, я в конечном счёте вернулся к умолчальнойMint-X. И даже отказался от её модификации — этому занятию ранее я тоже отдалсвою дань, и потому опишу в конце данного очерка.Модуль Фоновые рисунки в нынешней Cinnamon — это не просто банальные обои.Нет, конечно, их можно использовать и в этом качестве. Но самый цимес модуля —организация слайд-шоу из нескольких предустановленных наборов картинок,носящих имена былых и нынешних релизов Mint:  И не только из них — в качестве такого набора можно легко подключить каталог ссобственными изображениями, на следующем скриншоте таковым выступаетmy_backgrounds):  Модуль Шрифты позволяет определить гарнитуры, шрифтоначертания и кегли дляэлементов интерфейса, документов и терминальных окон. По умолчанию в качествеинтерфейсных (пропорциональных) шрифтов в Cinnamon, начиная с версии 2.4,используется гарнитура Noto Sans собственной выделки:  Мне эта гарнитура понравилась до чрезвычайности:    Особенно с учётом того, что она не одинока — в дополнение к ней имеется игарнитура с отсечками, как нетрудно догадаться, именуемая Noto Serif:    То есть семейство гарнитур Noto оказывается почти самодостаточным не толькодля интерфейса среды и её приложений, но и для оформления документов. Почти —потому что в нём явно не хватает какой-либо моноширинной гарнитуры дляиспользования в текстовых редакторах и терминальных окнах. Впрочем, я этовосполняю последнее время за счёт моноширинного представителя семействаLiberation — Liberation Mono. В результате чего мои шрифтовые настройкивыглядят следующим образом:    Тут нужно оговориться, что настройка шрифтов главного меню управляющей панели,подписей и всплывающих подсказок на ней возможна только путём прямогоредактирования стилевого файла выбранной темы рабочего стола, о чём будетговориться в следующем разделе этого очерка.А пока — про Эффекты. По умолчанию этот модуль выглядит таким образом:  До недавнего времени тут я просто снимал галочку с бокса Включить эффектырабочего стола и больше на эту тему не думал. Предоставляя разбираться с«красивостями» тем, кто таким образом охмуряет молоденьких вендузятнец. Однаков Cinnamon эффекты мне неожиданно понравились своей плавностью иненавязчивостью. Так что я затратил некоторое время на приведение к такомувиду:    На этом в данный момент я с оформлением закончил. Однако, как и обещал, подзанавес расскажу о том, как редактировать темы рабочего стола. Хотя, как ужебыло сказано, в конце концов я вернулся к умолчальной Mint-X, но как опыт этобыло интересно.Cinnamon и собственные темыВ отличие от большинства остальных очерков, в этом разделе я описываю неактуальную версию Cinnamon 2.4, а её предшественниц 2.0 и 2.2. Где ни однатема, даже самая красивая, не подходила мне целиком и полностью. В текущем жерелизе неожиданно оказалось, что тема по умолчанию, Mint-X, устраивает меня вовсех отношениях. Тем не менее, я решил включить описание моих тогдашнихразвлечений в эту книгу — вдруг когда возникнет желание заняться этим деломснова?Как только что было сказано, настройка шрифтов Cinnamon действует на всеэлементы его интерфейса, кроме панели и главного меню. Причём следствие,проведённое в то время, показало, что в панели и меню шрифты зависят от темыоформления: при смене её гарнитура в этих элементах интерфейса менялась, хотякегль оставался если не неизменным, то обычно маленьким и трудно различимым.После отправки дела на доследование оказалось, что так оно и есть: кеглишрифтов для меню и разных элементов панели (а в ряде случаев – даже игарнитуры) жёстко прописывались в CSS-файле всех тем, которые я просмотрел. Апоскольку все они были изготовлены зоркими соколами, кегли эти везде былиочень маленькими, от 7 до максимум 11 пунктов.Обсуждать вопрос о том, насколько это идеологически правильно, здесь не буду.Конечно, на мой взгляд, неправильно абсолютно – ибо противоречит идее сквозныхнастроек десктопа, последовательно проводимой в KDE и Xfce. Однако идеология –идеологией, а практика – практикой: поскольку это оказался чуть ли неединственный недостаток Cinnamon&#39;а, его следовало по возможности искоренить, ане рассуждать на темуЧто делать, блин?И кто, блин, виноват?!Что делать – было ясно: редактировать тему, наиболее близкую по всем остальнымпоказателям. А как делать – в принципе стало ясно из прочтения материалаКлемента Лефевра, к переводу илиоригиналу которого и отсылаюзаинтересованного читателя. Здесь же лишь кратко опишу последовательностьсобственных действий.В качестве подопытного кролика я выбрал тему Void, все относящиеся к ней файлыимели место быть у меня в каталоге ~/.themes/Void/cinnamon. В том числе иcinnamon.css, который я отредактировал самым простым способом: без лицемерияявным образом указал гарнитуру:stage {font-family: &quot;Cantarell&quot;;}Затем просто добавил один-два пункта к кеглям шрифтов всех интерфейсныхэлементов. А заодно из темы Canelita потырил пиктограмму для кнопки главногоменю – умолчально-зелёная в мою цветовую гамму вписывалась плохо.И вот что получилось в итоге:  "
},




{
"title": "Секция Параметры",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca070_section_parameters.html",
"summary": "",
"body": "Если модули секции Оформление отвечают за внешний вид среды Cinnamon, то всекции Параметры собраны модули, определяющие её поведение. Это — самаяобширная секция среди Системных настроек, и в полностью обозримом виде онавыглядит так:    Далее в этом очерке модули секции будут рассмотрены не в том порядке, вкотором они приведены на скриншоте, то есть алфавитном. А в порядке, диктуемомлогикой. Хотя начну рассмотрение я таки по алфавиту.АвтозапускМодуль Автозапуск предназначен для управления программами, автоматическизагружаемыми при старте сеанса Cinnamon, как системными, так и сугубоприкладными. По умолчанию список их выглядит так:    Способы коррекции списка очевидны: снятие «птицы» с соответствующего боксаотключает загрузку данной программы (например, mintwelcome, выводящейприветственную панель при запуске сеанса), кнопка Удалить исключает её изсписка вообще, а с помощью кнопки Добавить список пополняется программами пожеланию применителя. Для чего в появившейся панели надо заполнить поля Имя(желательно соответствующее имени программы), Команда (имя запускающего файла,при необходимости — с указанием пути) и, по желанию, Комментарий (в свободнойформе). Например, для выпадающего терминала Tilda (использование которого безавтозапуска лишено смысла) это выглядит так: В результате таких действий у меня панель автозапуска выглядит таким образом:    По умолчанию в панели автозапуска отображаются далеко не все автоматическизапускаемые приложения — в ней мы не увидим всякого рода системных служб.Чтобы сделать их видимыми, нужно отредактировать соответствующие конфиги вкаталоге /etc/xdg/autostart/, имеющие вид *.desktop. Каждый из них включает всебя параметр NoDisplay, отвечающий за вывод на экран, и значение его поумолчанию true. Которое достаточно заменить на false, чтобы увидеть весьстартовый букет служб и приложений. Сделать это в один присест можно припомощи утилиты sed, запущенной с правами администратора:$ sudo sed -i &#39;s/NoDisplay=true/NoDisplay=false/&#39; /etc/xdg/autostart/*Годится для этого и любой развитый текстовый редактор, позволяющий выполнятьпоиск и замену в серии файлов (Geany, Komodo Edit).В предыдущих версиях Cinnamon в панели автозапуска имелся боксик Автоматическизапоминать запущенные приложения при выходе из сеанса. Правда, работал он изрук вон плохо, и потому в текущей версии был в Системных настройкахликвидирован как класс. Но возможность включить сохранение сеансов сохраниласьв Редакторе dconf, о котором будет говориться своевременно.Апплеты, десклеты и расширенияАпплеты уже мельком упоминались в очерке об интерфейсе Cinnamon, а вот продесклеты и расширения речи ещё не было. Так что для начала скажу пару слов отом, что это такое.Название апплеты является уменьшительно-ласкательной формой английскогоapplication, то есть по русски — программульки, или маааленькие программы.Однако главное не в их размере, а в том, что они работают только внутридругих, «полноценных», программ, и не способны к самостоятельномусуществованию. В нашем случае апплетами являются пиктограммы управляющейпанели Cinnamon&#39;а, которые вне её не то что функционировать — жить не могут.Десклеты — это название принято в Cinnamon&#39;е для элементов, которые в другихрабочих средах называют виджетами (то есть «штуковинами»). Как и апплеты,самостоятельно роли они не играют. Но, в отличие от тех, встраиваются нарабочий стол (откуда, видимо, и название).Что же до расширений (extensions), их назначение понятно из названия: подобноплагинам и прочим add-on&#39;ам, они добавляют к базовой функциональности десктопадополнительные возможности (например, добавление второй нижней панели плюс кглавной управляющей).А теперь посмотрим, как эти самые апплеты, десклеты и расширениянастраиваются. Начав по алфавиту, с первых.Собственно, настройка апплетов сводится к двум моментам. Первый — этодобавление на панель уже установленных апплетов или, напротив, удаление с неёдобавленных:  Второй момент — загрузка списка апплетов не установленных, выбор из них нужныхи установка последних:    Я думаю, что обе задачи заинтересованный читатель сможет решить без труда. Каки вопрос с определением нужности или ненужности конкретных апплетов. Попрошутолько обратить внимание на апплеты Workspace switcher и Expo в спискепредустановленных, но не используемых — они скоро потребуются нам в одном изближайших разделов этого очерка.А при установке подгружаемых апплетов надо учитывать, что при переходе отCinnamon версии 2.2 к 2.4 произошла смена API. И, по сообщениям в Сети, не всеиз сторонних апплетов, сочинявшихся ещё для прежних версий, обязаны корректноработать в последнем релизе. Впрочем, со временем эта проблема теряетактуальность.С десклетами дело обстоит сходным во всех отношениях образом. Во-первых, ихтакже можно выбрать из числа предустановленных, каковых всего три:    Во-вторых, можно просмотреть список десклетов, доступных в Сети, и включить ихв список установленных:  В-третьих, можно настроить оформление десклетов (в рамке, с заголовком или безничего) и их размещёние (привязка к сетке с заданным шагом).:    Для подключения десклетов из списка установленных их остаётся только добавитьна рабочий стол — подобно пиктограммам рабочего стола, они появятся во всехрабочих пространствах:  Вопрос, нужны ли народу десклеты, остаётся спорным. С одной стороны,болтающиеся на экране дополнительные часы, калькулятор, информатор о занятостидисковых разделов или сводка погоды (а никакого иного полезного функционала ясреди них не обнаружил) не особенно и видны в рабочем режиме. Но с другой — ине мешают, а при случае могут и пригодиться.Однако тут надо учитывать два момента. Первый — к десклетам относится всёсказанное об апплетах относительно совместимости их с текущей версиейCinnamon.Второй момент — более существенный. Как показала практика, даже десклеты,заведомо предназначенные для соответствующей версии Cinnamon, могут работатьнекорректно и даже приводить всю среду в полностью неработоспособноесостояние.Правда, лечится это достаточно просто — нажатием кнопки Восстановитьстандартные настройки, если не помогло — ручной очисткой каталога~/.local/share/cinnamon/desklets, но всё равно радости мало. Учитываясомнительную пользу даже от тех десклетов, которые кажутся подозрительными наполезность.С расширениями ситуация ещё менее однозначна. В предустановленном виде их нетни одного, да и список доступных не так велик:  И среди существующих расширений вызывающих подозрения в своей полезностиоказалось не мало — например, CinnaDock, похожий, судя по описанию, на Cairo,упомянутый выше 2 Bottom Panels или трёхмерный переключатель задач — 3D App Switcher. Но слова относительно совместимости с Cinnamon 2.4 относятся красширениям ещё больше, чем к десклетам. В частности, ни одно иззаинтересовавших меня в текущей версии этой среды даже не устанавливалось, неговоря уже об активизации. Я понимаю, что со временем это всё устаканится — новот тогда и вернусь к этому вопросу.Панель и рабочий столПосле рассмотрения апплетов, десклетов и расширений логично будет перейти кконфигурированию элементов, их вмещающих — управляющей Панели и Рабочегостола.Правда, про настройки рабочего стола сказать особо нечего. Здесь можно толькоотметить, какие пиктограммы из заданного списка следует на него выводить:  Впрочем, модуль всё равно полезный, так как позволяет запретить выводпиктограмм на рабочий стол вообще, что я обычно и проделываю: в редкиемгновения, когда я вижу рабочий стол вообще, предпочитаю любоваться картинкойна нём, а не пялить глаза в какие-то пиктограммы.В модуле Панель по умолчанию всё достаточно стандартно — расположение её«традиционное», то есть внизу экрана:  Однако есть немало возможностей для видоизменения. Так, панель можетрасполагаться не только внизу, но и вверху экрана. Кроме того, их может бытьдве — и вверху, и внизу (как было по умолчанию в GNOME 2, и как ныне принято вего форке — MATE). Самое же главное — можно задавать произвольную высотупанели, с масштабированием текста и пиктограмм на ней:  Относительно автоматического скрытия всё понятно без комментариев — для кого-то это полезно, для иного же (например, для меня) — не удобно. А вот включениережима редактирования панели позволяет перетасовывать отдельные её элементы, вчастности, пиктограммы в Launcher&#39;е и в трее. Правда, при этом отключаетсязапуск с помощью кнопок приложений на ней — то есть свои рабочие функции онавыполнять перестаёт. Так что включать этот режим следует только на время —действительно при необходимости что-то перетащить.Здесь же уместно сказать и о модуле Блокировка экрана. Сама по себе блокировкас параметрами по умолчанию — штука, меня страшно раздражающая. Особенно когдадля разблокирования требуется ввод пароля. Так что первым делом я её отключаюнапрочь — даже на ноутбуке. Оставляю только включение, через разумныйпромежуток времени, скринсейвера (который здесь, впрочем, тоже называетсяблокировкой):    А вот сам скринсейвер — предмет гордости разработчиков, и гордости законной.Потому что в нём можно задать вывод времени и даты в период блокировки, причёмв собственном формате. Кроме того, вместо времени и/или даты можно указатьлюбой произвольный текст, напримерРуки прочь от моего компаВпрочем, текст можно указать и в специально предназначенном для этого поле,например, подобно Кристоферу Робину, вот такой:    Как можно видеть на скриншоте, предшествовавшем этому, настройке поддаются ишрифты вывода времени, даты и текстового сообщения.Окна и их тайлингВ очерке об интерфейсе Cinnamon говорилось о средствах управления окнами поумолчанию. Настало время посмотреть, как эти умолчания можно изменить.Разумеется, делается это через пункт Окна. Здесь можно настроить стандартныедействия при щелчках мышью на строке заголовка и режим передачи фокуса окну,если не устраивают умолчания — и думаю, очевидным способом. Меня умолчанияустраивают, так что вдаваться в подробности не буду.Самое же интересное здесь — это примирение «правосторонников»» и«левосторонников», то есть приверженцев расположения кнопок управления окном стой или другой стороны строки заголовка:    Как известно, в своё время революционная идея «левого уклона» кнопок в Ubuntuвызвала массу нападок со стороны «правых уклонистов» — твёрдых искровцевGNOME’вцев. В Cinnamon принято компромиссное решение — любые кнопки можнопоместить как с левой стороны титульной строки, так и с правой.Что, впрочем, тоже не ново, и испокон времён внедрено в оконных менеджерах KDEи Xfce. И чем я с давних пор пользуюсь — при общем «правом уклоне» делаю длякнопки закрытия окна «отмашку влево»: за долгие годы работы проверено, что этосильно снижает вероятность нажать её случайно, что обычно весьма нежелательно.В очерке об интерфейсе я много места посвятил описанию тайлинга окон — какодной из особенностей, делающих Cinnamon «лучшим из десктопов». Настраиваетсяже тайлинг в модуле Прикрепление окон и притяжение... Вот только настраиватьздесь особенно нечего: для приобщения ко всем прелестям тайлинга достаточноотметить боксик Включить режим прикрепления — а это и так сделано поумолчанию:    Что же до возможности изменить переключатель между режимами простого изащищённого прикрепления — мне она оказалась без надобности, умолчальныйControl справляется с этой задачей не хуже других.Смысл включения притяжения к границам (так называемый Flip) — вовсе не вкаком-то притяжении, а, как мне объяснили резонные люди, в самом обычномпереключении на соседнюю рабочую область при подведении курсора мыши к границетекущей. Это меня всегда раздражало во всех графических средах — и эту опцию явсегда отключаю.На счёт инверсии клавиш со стрелками ничего сказать не могу, ибо не ощутилнеобходимости. А вот режим, названный традиционным, оказался не вредным.Только означает он, вопреки тому, как можно понять написанное, следующее: приего включении, если вам не хочется, чтобы какое-либо окно «превращалось вчерепицу» при перемещёнии его к краю экрана, следует удерживать клавишу Shift.Рабочие области и Горячие углыГоворя в «интерфейсном» очерке о переключении между окнами, я вскользьупомянул о переключении в режим Expo, при котором на экран выводятся всеналичные рабочие области. А уже в этом очерке просил обратить внимание наодноимённый апплет. Настало время поговорить обо всех этих материях подробнее.В том же «интерфейсном» очерке говорилось, что рабочих областей в Cinnamon поумолчанию две, и способа изменить это число на поверхности не видно, апереключение между имеющимися возможно только по комбинации клавиш Control+Altс Right или Left. И всё это правда, чистая правда, но далеко не вся правда.Так, найти альтернативный способ переключения между рабочими областями не такуж и сложно даже при слабом знании английского. Это — упомянутый ранее апплетWorkspace switcher: будучи включённым, он выводит на панель обычныйпереключатель рабочих столов, привычный всем пользователям интегрированныхсред и многих оконных менеджеров: Далее, логично было бы ожидать, что количество рабочих областей можно задать вмодуле, который называется Рабочие области. Однако, открыв его, мы не увидимтам и намёка на эту опцию:  А смысл всех остальных опций этого модуля остаётся не очень понятным — так чторассмотрение его немного отложим.Потому что настало время вспомнить об апплете Expo. Ибо он служит дляпереключения Cinnamon в одноимённый режим — режим вывода на экран всехналичных рабочих областей одновременно:  Очевидно, что это ещё один способ переключения между рабочими областями — длячего достаточно кликнуть мышью на нужной. Но главное — это единственный способувеличить их число, для чего служит большой жирный плюс с правой стороныэкрана. А уменьшить количество рабочих областей можно с помощью крестика,появляющегося в правом верхней углу любой области при наведении на неёкурсора:  Вот теперь, просветлев относительно режима экспонирования, можно вернуться кмодулю Рабочие области, дабы осознать смысл его опций. И действительно, можнопредполагать, что загадочная опция Гарабиты, которые почему-то измеряются вмиллисекундах — это время задержки переключения в режим экспонирования,горизонтальное и вертикальное расположение в процентах — это размеры рабочихобластей при представлении в этом режиме, перелистывание — возможностьперемещёния между ними, прокручивая колёсико мыши. И радоваться своейсолдатской смекалке.Радость эта омрачается одним: изменение любой опции не влечёт за собой никакихпоследствий от слова абсолютно. И в результате оказывается, что единственныйрабочий пункт этого модуля — Показывать экспозицию как сетку. По умолчанию онвключён. Снятие же с него отметки приводит к тому, что рабочие области в Expo-режиме выстраиваются в одну линию:    Кстати, апплет Expo — не единственный способ переключения в одноимённый режим.Согласитесь, что было бы странно, если такая важная функция выполнялась спомощью внешнего апплета, да ещё и не включаемого по умолчанию. Главный,встроенный, способ перехода в режим экспонирования рабочих областей —комбинация клавиш Control+Alt+Up. Задействована и противоположная комбинация —Control+Alt+Down: Она переводит Cinnamon в режим, который можно назватьэкспонированием окон (или режимом масштабирования): одновременный вывод всехокон всех открытых приложений текущей рабочей области, в том числе исвёрнутых:    Однако и это ещё не всё: существует ещё один способ переключения в оба режимаэкспонирования. По умолчанию он отключён, а за его настройку его отвечаетмодуль Горячие углы. Он обеспечивает привязку к любому из углов экрана одногоиз трёх действий: переключения в режим экспонирования рабочих областей, врежим масштабирования окон или очистку рабочего стола (то есть сворачиваниявсех окон). Действия эти происходят при подведении курсора мыши ксоответствующему углу. Повторное перемещёние курсора в тот же угол возвращаетCinnamon в нормальный рабочий режим.На следующем скриншоте в качестве «горячего» выступает правый нижний угол — кнему привязано экспонирование рабочих областей:  Кроме того, потенциально через «горячий угол» можно выполнить произвольнуюкоманду. Так, на следующем скриншоте приведена попытка настроить правыйверхний угол на вызов выпадающего терминала Tilda:    Однако практика показала, что это неудобно, в том числе и потому, что прикаждом наведении на «горячий угол» вызывался новый экземпляр терминала,который для начала желал, чтобы его настроили. А никакого другого примененияэтой фиче я не придумал. Может, у кого из читателей фантазия окажется богаче?Конфиденциальность, Общие, УведомленияОбщего между этими тремя модулями, пожалуй, только то, что они былипереработаны при переходе на Cinnamon версии 2.4.Вся настройка конфиденциальности сводится к решению вопроса, запоминать лиоткрываемые файлы, и если запоминать — навсегда или на какой-то определённыйсрок:  Я остановился на варианте «вечного хранения».В модуле Общие обнаружилась интересная функция — возможность масштабированиярабочего стола. Для этого надо значение по умолчанию, Автоматически    заменить на Двукратный (HiDPI):  Правда, после этого рабочий стол приобретает устрашающий вид даже для моегозрения:    Но возможно, что в некоторых случаях это будет менее плохо, чем не видетьникакого вида вообще. Ну а пока я поспешил вернуться к виду нормальному (оноказался идентичным автоматическому).В модуле Уведомления можно, во-первых, отказаться от их вывода (по умолчаниюон, разумеется, включён). Они часто раздражают — например, сообщения IM-клиента о том, что гражданин Имя Рек вошёл в сеть, а гражданин Некто из неё,напротив, вышел. Однако совсем отключать уведомления неправильно, потому чтовременами они несут разумное, хотя обычно как раз не доброе. А вот удалятьсообщения по истечении тайм-аута — как раз разумно, что и проделано наскриншоте:  Кроме того, здесь же можно отрегулировать прозрачность уведомления, инемедленно протестировать это дело нажатием на соответствующую кнопку:  Я уменьшил прозрачность практически до минимума, так как иначе ничего невидел. А ведь уведомления — для того, чтобы их читать, не так ли?Детали учётной записиНе смотря на название модуля, Детали учётной записи, никаких особых деталейтам нет:  А есть возможность поменять пароль (к чему в некоторых случаях время отвремени прибегать приходится) и изменить логин. Хотя вот последнего как разделать не следует: численный идентификатор пользователя (так называемый UID)при этом не меняется, так что, скажем, на правах доступа к файлам этосказаться не должно. Но в каких-то случаях программы могут обращаться не кUID&#39;у, а именно к названию аккаунта, и ничего, кроме путаницы, это не даст.Зато можно приклеить собственную аватарку, как это видно на скриншоте.Прочие параметрыПо остальным пунктам секции Параметры я позволю себе пробежаться галопом — ониили не очень существенны (с моей точки зрения), или тривиальны. Неохваченнымиу нас остались (слева направо и сверху вниз):Дата и время, смысл которого очевиден:  Приложения и съёмные носители — аналогично:      Ну а Специальные возможности — они и есть специальные:  Не смотря на то, что они предусмотрены во всех рабочих средах и вроде быпредназначены как раз для таких как я (в частности, плохо видящих), прибегнутьк ним мне не приходилось: они либо не нужны, либо бесполезны.Я умышленно не сказал ничего о модуле Языки. Потому что на самом деле это немодуль Системных настроек Cinnamon, а одна из фирменных утилит Mint, в рядукоторых и будет рассмотрена в одном из последующих очерков."
},




{
"title": "Секция Оборудование",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca080_devices.html",
"summary": "",
"body": "В секции Оборудование собраны модули, имеющие, как ни странно, отношениеименно к оборудованию. И обозреть их все единым взглядом можно здесь:  А поскольку внутренней логикой они не особо между собой связаны (за однимисключением), и к тому же кое-какого оборудования у меня просто нет, торассматривать эти модули я буду в произвольном порядке, руководствуясьсобственными соображениями о их важности. Начав, однако, с самого общего — Осистеме.О системе и дисплееМодуль О системе не предусматривает никаких настроек, а просто выводитсведения о ней, родимой, в простой и наглядной форме:  Думаю, тому, кто знает такие слова, как операционная система или процессор, несоставит очень большого труда догадаться о том, что означают и соответствующиеим значения.Модуль Дисплей я приплюсовал сюда же, так как в случае одномониторнойконфигурации, да ещё и не с поворачивающимся экраном, он тоже просто выводитсамые общие сведения о мониторе и его разрешении:    Во всех же прочих пунктах секции предполагается совершение некоторыхнастроечных действий. Из них для нас важнейшим является настройка клавиатуры —с неё-то и начнём.КлавиатураВ модуле Клавиатура для начала можно настроить поведение при нажатии клавиш иреакцию курсора:  А во второй вкладке, Комбинации клавиш, определить хоткеи на очень многиеслучаи жизни:    В частности, здесь я в обязательном порядке устанавливаю клавишные комбинациидля переключения между рабочими областями — Alt+1, Alt+2 и так далее (пунктРабочие области):  В некоторых случаях может быть полезным назначение хоткеев для перемещёнияокон в подпункте Размещёние пункта Окна — в правый верхний угол, левый верхнийугол, и так далее (по умолчанию не включены):  Такие перемещёния не следует путать с управлением тайлингом — размер окна приэтом не меняется. А собственно настройки управления тайлингом выполняются втом же пункте Окна — соответствующий подпункт так и называется, Tiling andSnapping. Именно здесь можно изменить умолчальные комбинации типа Super плюсстрелки, описанные в предыдущем очерке:  В пункте Общие (он идёт первым в списке) можно перенастроить переходы в режимExpo и масштабирования:  Раньше здесь же можно было лишить клавишу Super_L (она же — левая win-клавиша)её сакрального значения — вызова меню. В версии 2.4 эта возможность пропала,но кто знает? Может, появится снова. Ведь Cinnamon — не Unity, где всё насупер-клавишу завязано, так что нет смысла трястись над этой священнойкоровой.В мои цели не входит описывать все действия, для которых можно определитькомбинации. Но думаю, что и сказанного достаточно для иллюстрации факта: передлюбителями оперировать хоткеями открывается очень широкое поле деятельности.Вкладка Раскладки клавиатуры очень важна для для многих применителей-текстовиков, и потому её рассмотрение выделяется в особое производство.Раскладки и переключателиНастройка раскладок клавиатуры и переключателей между ними может быть неактуальной для тех применителей, которых устраивают умолчания инсталлятора —вариант winkeys для русской раскладки и комбинация Alt+Shift в качествепереключателя раскладок:  Но для требовательных применителей-текстовиков здесь есть все возможности неизменять своим привычкам, а заодно и приобрести новые, полезные.Перво-наперво следует определиться, использовать ли одинаковую раскладку вовсех окнах, или в каждом — свою, что делается отметкой одной изсоответствующих радиокнопок (см. предыдущий скриншот). А во втором случае —решить, будет ли раскладка нового окна наследоваться от таковой окнапредыдущего, или же от умолчальной раскладки, той, что стоит в списке первой(на самом деле это тоже раскладка окна — так называемого корневого окнаИксов).До некоторого времени наследование раскладки в Cinnamonm работало произвольнымобразом. В версии 2.4 это изжито, и при включении последней опции раскладка вновом окне действительно будет умолчальной. За единственным, отмеченным ранее,исключением: в строке инкременетного поиска главного меню среды раскладкапочему-то всегда наследуется от текущей.Далее переходим к выбору варианта русской раскладки. Список их включает всеобычные варианты, немало экзотических и несколько национальных:    В случае сомнений раскладку можно, с помощью кнопки Предпросмотр, поглядеть наэкране:  Я, ввиду большого стажа ремингтониста (это — мужской вариант профессимашинистки), предпочитаю вариант Typewriter Legacy, обзываемый по русскипечатная машинка, устаревшая. Вдаваться в обоснования этого выбора и тем болееагитировать за него здесь неуместно. Заинтересованных отсылаю к специальномуматериалу.Из прочих вариантов интересен вот этот: Русский (Польша, фонетический Дворак).Чего там осталось от раскладки профессора Дворака — разве что то, что это иблизко не QWERTY. Но расположение алфавитно-цифровых символов и знаковпрепинания на ней выглядит вполне разумным:  Правда, есть большие сомнения в том, что эта разумность стоит полногопереучивания.Нет напряга и с переключателями раскладок — они входят в число параметров,вызываемых, как ни странно, кнопкой Параметры: Легко догадаться, что переключение настраивается в пункте Переключение надругую раскладку, и в нём можно найти переключатель на любой вкус:   Имеются и немодальные переключатели — это своего рода заменители корректоровввода при «неправильной» раскладке, примером которых в Linux&#39;е выступаетпрограмма X Neural Switcher (точнее, в Иксах, ибо работает также и в любыхBSD-системах). Ибо из применителей может сказать, положа руку на сердце ипоклявшись на своём Священном Писании, что он никогда, никогда, никогда... незабывал переключать раскладку клавиатуры с латиницы на кириллицу (илинаоборот)?Достоинства и недостатки XNeur обсуждались многократно, поэтому повторю толькоглавный из последних: эта утилита принадлежит к тем, которые полагают себяумнее своих создателей (и, тем более, применителей), и потому часто автоматикаего срабатывает прозвольным образом. Конечно, он имеет и «ручной» режимработы, но его использрвание очень узко: если вовремя заметить, что в «не той»раскладке набрано одно слово или его кусок, обычно проще и быстрей тут жеперенабрать его, нежели выделять кусок текста и заказывать для негоперекодирование.Тем более, что «проблему забывчивости» применительно к переключению раскладокможно попытаться решить другим способом — я бы назвал его «кембриджским». Какизвестно, в Оксфордском университете, воспитывавшем английских джентльменов,учили мыть руки после туалета. А в более прагматичном Кембридже, давшем мирунемало естествоиспытателей, учили не справлять малую нужду на руки. Первомуалгоритму следует программа XNeur, второй же можно реализовать, сведя кминимуму вероятность забывчивости при наборе. Чему очень поспособствуют тесамые немодальные (или нециклические) переключатели раскладок.Суть немодальных переключателей в том, что они ничего не переключают, авключают. То есть одна определённая клавиша (или их комбинация) всегдавключает английскую раскладку, а другая делает то же самое для раскладкирусской. И в использовании их есть только одна проблема — привыкание. То естьнужно отучиться смотреть на индикаторы раскладки. Нужно забыть о том:какая раскладка является текущей; какая раскладка является умолчальной; от кого наследуется раскладка нового окна — от корневого окна (то есть повторяет умолчальную) или от окна текущего. А помнить нужно только одно: перед вводом любого кириллического текста нажать,скажем, комбинацию Shift+CapsLock, а переходя к вводу латиницы — клавишуCapsLock. Подобно тому, как при вводе прописной буквы мы автоматическинажимаем Shift, не задумываясь особо о причинах этого.Немодальных переключателей предлагается довольно много:  Далее, чтобы побороть забывчивость при переключении раскладок, надопереключать их как можно реже. И на сей предмет придуманы временныепереключатели, действующие, пока нажата определённая клавиша — в частности,они совершенно незаменимы при вводе типографских символов с использованиемклавиши Compose, о чём я скажу чуть позже. Причём они не исключаютиспользования любых постоянных переключателей, как модальных, так инемодальных.Традиционно в качестве временного переключателя используется правая клавишаControl, но и тут выбор достаточно велик:  А вообще все возможные переключатели раскладок, модальные, немодальные ивременные, можно посмотреть в файле /usr/share/X11/xkb/rules/evdev.lst — всекции ! option, где они перечислены в строках, начинающихся с grp:! option  grp                  Switching to another layout  grp:switch           Right Alt (while pressed)  grp:lswitch          Left Alt (while pressed)  grp:lwin_switch      Left Win (while pressed)  grp:rwin_switch      Right Win (while pressed)  grp:win_switch       Any Win key (while pressed)  grp:caps_switch      Caps Lock (while pressed), Alt+Caps Lock does theoriginal capslock action  grp:rctrl_switch     Right Ctrl (while pressed)  grp:toggle           Right Alt  grp:lalt_toggle      Left Alt  grp:caps_toggle      Caps Lock  grp:shift_caps_toggle Shift+Caps Lock  grp:shift_caps_switch Caps Lock (to first layout), Shift+Caps Lock (to lastlayout)  grp:win_menu_switch  Left Win (to first layout), Right Win/Menu (to lastlayout)  grp:lctrl_rctrl_switch Left Ctrl (to first layout), Right Ctrl (to lastlayout)  grp:alt_caps_toggle  Alt+Caps Lock  grp:shifts_toggle    Both Shift keys together  grp:alts_toggle      Both Alt keys together  grp:ctrls_toggle     Both Ctrl keys together  grp:ctrl_shift_toggle Ctrl+Shift  grp:lctrl_lshift_toggle Left Ctrl+Left Shift  grp:rctrl_rshift_toggle Right Ctrl+Right Shift  grp:ctrl_alt_toggle  Alt+Ctrl  grp:alt_shift_toggle Alt+Shift  grp:lalt_lshift_toggle Left Alt+Left Shift  grp:alt_space_toggle Alt+Space  grp:menu_toggle      Menu  grp:lwin_toggle      Left Win  grp:rwin_toggle      Right Win  grp:lshift_toggle    Left Shift  grp:rshift_toggle    Right Shift  grp:lctrl_toggle     Left Ctrl  grp:rctrl_toggle     Right Ctrl  grp:sclk_toggle      Scroll Lock  grp:lctrl_lwin_rctrl_menu LeftCtrl+LeftWin (to first layout), RightCtrl+Menu (to second layout)Руководствуясь этим списком, переключатели раскладок (в числе прочихпараметров) можно изменить и через Редактор dconf, о котором со временемпойдёт речь.Кроме того, настройкой переключателей параметры клавиатуры не исчерпываются.Например, на десктопах резонно Использовать клавиатурные индикаторы дляотображения дополнительных раскладок:  В ряде случаев полезно в Разных параметрах совместимости установить опцию Склавиш цифровой клавиатуры всегда вводятся цифры — вне зависимости от настроекBIOS и общесистемных:  И, наконец, сакраментальный вопрос о вводе типографских символов. Хотя ужедавно, как заметил Brego,...данная задача решается не просто и даже не очень просто, а примитивно.А именно — так. Для начала поддержку ввода типографских символов следуетвключить — это делается в тех же Разных параметрах совместимости (см.предыдущий скриншот).Далее нужно определить Положение клавиши Compose — она служит для переключенияв режим ввода единичного типографского символа. Список вариантов тут более чемобширен:  И последнее, но самое главное: затвердить, как символ веры (своей, разумеется)список кейбиндов для типографских символов. Если и не полный, который можнонайти в файле /usr/share/X11/locale/en_US.UTF-8/Compose, то хотя бысуперминималистический, образуемый с помощью Compose плюс:--.         —       en dash---         —       em dashspb spb     nbsp    неразрывный пробел&amp;lt;&amp;lt;          «       открывающая кавычка &amp;gt;&amp;gt;          »       закрывающая кавычка..          …       многоточие&lt;/span&gt; &lt;/p&gt;oo          °       градус&lt;/span&gt; &lt;/p&gt;+-          ±       плюс-минус&lt;/span&gt; &lt;/p&gt;oc          ©       копирайт&lt;/span&gt; &lt;/p&gt;^2          ²       в квадрате&lt;/span&gt; &lt;/p&gt;12          ½       одна вторая&lt;/span&gt; &lt;/p&gt;Набор любой степени — Compose ^ #&lt;/span&gt; &lt;/p&gt;где # — нужная степень&lt;/span&gt; &lt;/p&gt;Набор (почти) любой дроби — Compose  x y&lt;/span&gt; &lt;/p&gt;где x — числитель, y — знаменательПравда, правила для набора дробей имеют исключения. Так, в моей системе невыводятся все дроби, содержащие цифру 7, что в числителе, что в знаменателе.За единственным исключением — дробь ⅞ почему-то пропечатывалась. Не печатаютсятакже и дроби с цифрой 9, в том числе и бессмысленные, тип 3/9 и 9/3. Причёмдевятка не проходит ни в каких сочетаниях, и ни в какой позиции, без всяких, вотличие от семёрки, исключений.Да, ещё самое распоследнее: следует помнить, что ввод типографики послеCompose работает только при латинской раскладке клавиатуры. И вот тут-то самоевремя вспомнить о временных, или «удержальных», переключателях — при некоторомнавыке они здорово упрощают ввод типографики.Мышь и сенсорная панельО настройках мыши мало что можно сказать. Разве что рассмотреть скриншот ирешить, что следует здесь поменять — и следует ли что-то менять вообще. Дляменя оказалась полезной опция Показывать позицию указателя при нажатии клавишиCtrl — способствует отысканию курсора, если он затерялся в океане безбрежногоширокоформатного монитора:    А вот настройка сенсорной панели — очень существенный момент при работе наноутбуке. Хотя на своей Ноутбучке я ограничился переключением режима прокрутки— водить по ней двумя пальцами мне удобней, чем елозить одним по краю:  Но, как хвастаются разработчики (и как видно на скриншоте), в Cinnamon 2.4появилась поддержка «однокнопочных» тачпадов — от Macbook&#39;ов этой модойзаразились и производители некоторых «обычных» ноутбуков. Действительно,опции, имеющие к этому отношение, присутствуют. Но что они делают и какработают — проверить не смог, ибо моя Ноутбучка имеет две натуральные,традиционно ориентированные, кнопки.Раз уж речь зашла о ноутбуках, добавлю тут же пару слов про модуль Управлениепитанием. Я этим вопросом особенно не заморачиваюсь, ограничиваясь отключениемвсего того энергосбережения, которое можно отключить:  А с прочими опциями предлагаю разбираться заинтересованным лицам. Как и смодулем Bluetooth, поскольку соответствующие устройства я не использую.ЗвукС настройками звука дело теоретически обстоит так: запустив соответствующиймодуль, можно для начала определить устройство воспроизведения оного. У менятаковым по умолчанию выставляется HDMI, по которому подключён монитор совстроенными колонками. Ни малейшего звука при этом не воспроизводится — онначинает звучать только при переключении на аналоговый выход (S/PDIF у менянет):    После чего остаётся проверить звучание — с неизменно превосходным результатом:  И слушать музыку или смотреть кино со звуковым сопровождением — штатными лисредствами Mint (Banshee и Totem, соответственно) или через более привычныймне Mplayer.Принтеры и цветВ секции Оборудование остались неохваченными вниманием два модуля — и описаниеобоих вполне уместится на одну страницу. Обратившись у пункту Принтеры, яувидел, что у меня нет настроенных принтеров:   Поскольку физически у меня имелось МФУ DeskJet 2050, я нажал кнопку Добавить —и увидел, что такое действительно имеет место быть:  Оставалось его настроить — для чего была нажата кнопка Вперёд, после чего быловыведено некое умолчальное описание принтера:    Его можно подкорректировать, но я этого делать не стал. А нажал кнопкуПрименить, через несколько секунд, ушедших на поиск драйверов, получилпредложение напечатать пробную страницу: Вслед за чем оказалось, что принтер волшебным образом у меня появился: И свойства его оказались таковы:    Надо сказать, что всё это потребовалось только потому, что при инсталляцииMint 17.1 Rebecca с нуля я не включил принтер. Иначе всё было бы автоматическиустановлено посредством HPLIP (HP Linux Imaging and Printing). Именно так былоу меня при установке Mint 17 Qiana — ни малейших усилий по настройке принтерая тогда не прикладывал. Но, когда он мне понадобился впервые (а принтер мнетребуется максимум раз в квартал), обнаружил, что он есть и готов к работе.Кстати, в обоих случаях моё МФУ, в соответствие со своим многофункциональнымтитулом, способно и сканировать — причём опять-таки без всяких настроечныхдействий. Что, впрочем, к нынешней теме не относится. Да и ставить это надо взаслугу не Cinnamon, и даже не Mint, а фирме HP и разработчикам системы HPLIP.Вот уже в который раз и на котором дистрибутиве я убеждаюсь, что HPLIPполностью избавил применителя от забот о настройке печати и сканирования.Правда, только счастливого обладателя продукции HP.И, наконец, последний модуль секции носит имя Цвет, а суть его заключается вкалибровке цветов монитора и принтера. Поскольку я в этом ничего не понимаю ини малейшей потребности понимать не испытываю, ограничусь скриншотом:  А уж кому нужно или интересно — делайте с ним что хотите."
},




{
"title": "Секция Администрирование",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca090_admins.html",
"summary": "",
"body": "Наступает волнующий момент — среди штатных настроек Cinnamon&#39;а осталась однасекция -- Администрирование, а в ней — четыре модуля:Источники приложений; Менеджер драйверов; Окно входа в систему; Пользователи и группы. Первые два модуля прямого отношения к Cinnamon не имеют, а принадлежат к кругуфирменных утилит Mint, которые будут предметом соответствующего очерка. Такчто в очерке этом будут рассмотрены два последних.Окно входа в системуСтрого говоря этот модуль тоже не часть среды Cinnamon, а являетсяинструментом настройки дисплейного менеджера MDM (изначально аббревиатура MintDisplay Manager, ныне превратившаяся в рекурсивное MDM Display Manager),обеспечивающего во всех редакциях дистрибутива Mint авторизацию в системе.Однако он очень тесно интегрирован в Системные настройки, в том числе и вотношении внешнего вида, и потому его целесообразно рассмотреть здесь.Поскольку авторизация в системе выходит за пределы компетенции отдельногопользователя, при запуске этого модуля (из CLI его можно запустить командойsudo mdmsetup) для начала запрашивается пароль, после ввода которогопоявляется такая панель:    С пунктом Тема всё понятно — это выбор заставки, на фоне которой выводитсяокно авторизации, а также, при желании, определение собственного приветствия:  Далее можно задать автоматический вход в систему для определённогопользователя, и установить задержку перед входом, позволяющую выбрать сеанс:  Сеанс по умолчанию задаётся в пункте Настройки:  Здесь же есть вожделенная для начинающих линуксоидов опция — разрешениеавторизоваться в иксовом сеансе в качестве суперпользователя. Что, конечно,круто, но делать не рекомендуется, за исключением единичных ну оченьспециальных случаев.Пользователи и группыА вот модуль Пользователи и группы — родной для Cinnamon, из CLI его можнозапустить командой cinnamon-settings-users. Очевидно, что и здесь потребуетсяпароль, ввод которого даст доступ к святая святых — списку пользователей игрупп:    От описания возможных тут действий в каждом аккаунте позволю себе воздержаться— они почти очевидны из скриншота и становятся более чем очевидными после парыщелчков мышью. А вот о том, как создаётся новый пользовательский аккаунт,скажу чуть подробнее.Собственно, для создания аккаунта достаточно заполнить простую форму, выбрав вней тип учётной записи: Тут возможно два варианта — Администратор и Стандартный. Второй выводится поумолчанию — и пусть таковым остаётся (почему — скажу чуть позже). Так чтотеперь достаточно нажать кнопку Добавить, чтобы новый пользователь появился всписке оных:  Обращаю внимание, что пароль в ходе создания нового аккаунта не запрашивается.Его можно установить здесь же, щёлкнув на поле Пароль: Впрочем, я по ряду причин предпочитаю делать это из CLI командой$ sudo passwd usernameТолько после этого надо не забыть исключить пользователя из группыnopasswdlogin, членство в которой даёт возможность беспарольного входа всистему, что не есть правильно. Для этого достаточно щёлкнуть мышью на полеГруппы и снять отметку с соответствующего боксика: Здесь, во-первых, надо подчеркнуть, что беспарольный вход в систему — этосовсем не то же самое, что автоматический вход, о котором говорилось выше: во-втором случае пароль пользователя существует, просто его не нужно вводить вокошке MDM (это, в соответствие с названием, делается автоматически, закадром). А вот при авторизации в консоли этому самому «автоматическому»пользователю пароль вводить придётся. Как и при запуске программ, требующихправ администратора. И, чтобы ни говорили записные параноики, с точки зрениябезопасности на локальной машине, находящейся в индивидуальном пользовании,автоматический вход ничем не отличается от парольного.Во-вторых, поясняю, в чём отличие административного типа учётной записи отстандартного: только пользователь с аккаунтом первого типа имеет возможностьполучить доступ к административным привилегиям с помощью команды sudo.Административный статус автоматически присваивается тому пользователю, чейаккаунт был создан при инсталляции системы. Так что для всех остальныхаккаунтов достаточно статуса стандартного. Ибо зачем нам два генеральныхсекретаря? — резонно говорил незабвенный Леонид Ильич (правда, не в жизни, а ванекдоте)И в-третьих, может возникнуть вопрос, зачем на индивидуальной машине несколькоаккаунтов? Причины могут быть разные, скажу только за себя. Мой первый иглавный аккаунт, alv, предназначен для меня, любимого, когда он занятвыполнением своей непосредственной работы. Например, сочинением этой книжки.Никаких потенциально опасных действий я под основным аккаунтом не делаю (илистараюсь не делать). Для всякого рода экспериментов предназначен аккаунт exp,пользователь которого не имеет доступа к правам администратора и потомунапортачить на системном уровне не может — в его власти только развалитьсобственные пользовательские настройки. Поскольку такое рано или позднослучается — на помощь приходит аккаунт def, в котором сохраняются всенастройки по умолчанию. И из которого настройки несчастного exp можновосстановить до исходного состояния простым копированием конфигов.На этом разговор о настройках Mint совместно с Cinnamon можно считатьзаконченным. Следующий очерк имеет отношение только к Mint, так как посвящён«фирменному» иснтсрументарию этого дистрибутива — и не только имеющемуотношение к настройкам."
},




{
"title": "Mint: фирменный инструментарий",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca100_mint_utils.html",
"summary": "",
"body": "Редкий дистрибутив из числа тех, что носят это гордое имя по праву, не обзаводится более или менее полным набором системного инструментария, специфичного только для него (в дальнейшем я буду называть такие инструменты фирменными). Не исключение в этом отношении и Mint — он имеет набор фирменных инструментов для решения весьма широкого круга задач, от управления программным обеспечением до настройки WiFi и блокировки доменов. Они и будут предметом данного очерка.ВступлениеКак уже было сказано, фирменный инструментарий дистрибутива Mint охватывает весьма широкий круг задач и потому представлен большим количеством отдельных утилит, которые обнаруживаются в любой из его редакций, располагаясь в каталоге /usr/bin. Полный их список включает более 20 исполняемых файлов вида mint*. Большинству из них соответствует пункт в разделе Администрирование главного меню Cinnamon: Фирменные инструменты Mint будут рассмотрены на примере среды Cinnamon. Однако десктопная специфика касается только способа их запуска из главного меню. Сами же инструменты идентичны во всех редакциях дистрибутива Mint.Рассмотрение фирменного инструментария целесообразно начать с менеджера программ, как наиболее востребованного его компонента.Менеджер программ mintinstallМенеджер программ mintinstall занимает центральное положение в наборе фирменного инструментария дистрибутива Mint. Он принадлежит к классу самых «высокоуровневых» инструментов для управления пакетами, которые можно назвать интегрированными центрами приложений, о чём подробнее будет сказано в одном из последующих очерков.Как только что было сказано, mintinstall можно запустить одноимённой командой из терминального окна или строки минитерминала. А можно обратиться к главному меню Cinnamon, где он обнаруживается в разделе Администрирование. Однако залезать в него не обязательно — пиктограмма запуска Менеджера приложений вынесена в левую колонку быстрого запуска второй сверху: Будучи запущенным тем или иным способом, mintinstall для начала запрашивает пароль пользователя, после чего предстаёт перед его взором в следующем виде: Первое, что обращает на себя внимание — минималистичный дизайн: никаких баннеров, новинок, рекомендаций. Только поле поискового запроса, пиктограммы категорий софта и строка состояния текущих действий (сразу после запуска, разумеется, пустая). И потому mintinstall не вызывает визуального отторжения.В обращении mintinstall столь же прост, как и внешне. А обращение с ним, разумеется, начинается с поиска нужного пакета. Сделать это можно, во-первых, просматривая категории, например Офис: Однако это не самый простой путь. Во-первых, просматривать списки категорий (а они включают в себя от пары сотен до 4-5 тысяч позиций) — не самое весёлое занятие. Во-вторых, оно осложняется ещё и тем, что пакеты в этих списках отсортированы не по алфавиту, а по количеству полученных отзывов. В-третьих, критерии отнесения пакета к той или иной категории не всегда понятны. Так, категория Офис включает в себя не только собственно офисные пакеты, но и, скажем, текстовые редакторы, в том числе и такие, которые обычно относятся к классу системных приложений, например, vim и nano, и даже к инструментам программирования, вроде текстового редактора Geany, в некоторых кругах именуемого интегрированной средой разработки (IDE).Впрочем, Geany мы не увидим ни в категории Офис , ни в категории Программирование. Ибо, и это в четвёртых, есть ещё и категория Избранное, куда попадают пакеты с наибольшим количеством отзывов в своих «законных» категориях. Именно к этой категории и удостоился чести быть причисленным Geany, имеющий на момент сочинения этих строк 473 отзыва: Поэтому, если известно имя пакета (или хотя бы фрагмент имени), проще воспользоваться полем поискового запроса. Таким образом пакет Geany находится мгновенно — а если после его нахождения нажать кнопку Показать все результаты, то будет выведен и список всех его плагинов:По умолчанию поиск в mintinstall простой, но его легко сделать инкрементным (как — скажу чуть позже). И тогда с каждым набранным символом список соответствий сокращается. Например, при поиске пакета Shutter, предназначенного для изготовления скриншотов (иллюстрации ко всем заметкам сделаны именно им), это выглядит так:Нужно только учитывать, что порядок вывода пакетов — не по соответствию имени введённым в поле поиска символам, а опять же по количеству отзывов.Впрочем, по умолчанию поиск осуществляется по соответствию не только имени пакета, но также и кратким описаниям, которые могут быть даже на русском языке. Это можно видеть на примере поиска пакета aisleriot, представляющего собой коллекцию пасьянсов: Следует помнить, что поиск — регистро-зависимый. Это можно продемонстрировать на примере поиска пакетов выпадающих терминалов. Если в поле поиска ввести слово Выпадающий, мы увидим пакет выпадающего терминала Guake:А по ключевому слову выпадающий обнаружится совсем другой выпадающий терминал, Tilda:Если дважды кликнуть на строке с именем найденного пакета, появится страница с его описанием. Нередко оно будет на русском языке, и может содержать картинки: Картинки кликабельны, так что их можно вывести «крупным планом»:Здесь же можно прочитать и отзывы о пакете, если таковые имеются: А можно также и оставить свой отзыв. Правда, для этого надо предварительно зарегистрироваться в сообществе пользователей (как — расскажу позже).Определившись, путём чтения описания и, возможно, отзывов (хотя они очень редко несут какую-либо информацию кроме эмоций), с нужностью найденного пакета, его остаётся только установить. Для чего требуется нажать соответствующую экранную кнопку — и процесс начнётся без единого вопроса.Столь же молчаливо будут установлены и все необходимые зависимости, поэтому с их списком лучше ознакомиться заранее. Например, для игры blockout2 он выглядит так: После установки пакета на его странице появляется кнопка Удалить очевидного назначения, которое также претворяется в жизнь без всяких вопросов. Нужно только учитывать, что пакеты, установленные как зависимости удаляемого, удалены не будут, их придётся вычищать или по списку по списку из раздела Подробности, или другими средствами. Первый вариант — рискованный, так как при этом можно затронуть зависимости других пакетов. Второй же лежит вне темы данного очерка — о нём будет говориться в своё время. Так что для удаления пакетов Менеджером программ лучше просто не пользоваться, за исключением очень простых или хорошо известных применителю случаев.Кроме строки поиска, mintinstall имеет ещё и меню. Где в пункте Вид определяется, выводить ли Доступные приложения, Установленные приложения, или, как по умолчанию, те и другие:В пункте Правка — три подпункта: Настройки поиска, Доступ к аккаунту в сообществе и Источники приложений:В первом из них, во-первых, определяется, искать ли только в кратких описаниях пакетов (отмечено по умолчанию) или также в подробных, а во-вторых — включить инкрементный поиск (Поиск при вводе):Про аккаунт в сообществе Linuxmint я расскажу в маленькой интермедии. А пункт Источники приложений вызывает отдельную утилиту software-sources, которая будет рассмотрена последующем за ней очерке.Интермедия об аккаунте в сообществеКак мы только что видели, для того, чтобы оставить отзыв о пакете в Менеджере программ, необходимо открыть аккаунт в сообществе Linux Mint. Для этого надо пройти к пункту меню Правка -&gt; Ваш аккаунт, который вызовет панель с предложением к авторизации:Нетрудно догадаться, что если аккаунта ещё нет — следует пойти по указанному там адресу. После чего приглашение к авторизации откроется уже в браузере:Кнопка Register находится на видном месте. Нажав её, можно видеть регистрационную форму:Заполнение полей — очевидно, кроме последнего, Registration Code. Чтобы получить его, нужно открыть тот самый экран приветствия, который был виден при первом запуске свежеинсталлированного Mint&#39;а. И показ которого, скорее всего, был тогда же и отключён. Однако его можно вызвать в любой момент — это такой же компонент фирменного инструментария, как и все остальные из рассматриваемых в этом очерке. Делается это либо из терминала вводом команды$ mintwelcomeлибо через главное меню Параметры -&gt; Экран приветствия: Теперь остаётся только найти пиктограмму с подписью Чат-комната, в эту самую комнату войти и в свободной (но желательно вежливой) форме на английском языке запросить код для регистрации. Практически мгновенно от пользователя mintbotd придёт ответ, гласящий, что код выслан в личном сообщении. Откуда он и вставляется в регистрационную форму, после чего регистрация мгновенно совершается.Теперь можно вернуться к форме, вызванной из Менеджера программ, авторизоваться там и оставлять отзывы в своё удовольствие. Причём устанавливать программу, на которую даётся отзыв, совсем не обязательно. А вот оценку ей надо дать непременно.Разумеется, аккаунт в сообществе нужен не только для того, чтобы оставлять отзывы на пакетах. Будучи членом сообщества, можно получать доступ к тому, что создаёт его мозг (Клемент Лефевр) на ранних стадиях разработки. И даже поучаствовать в тестировании.Менеджер репозиториев software-sourcesА теперь вернёмся в Менеджер программ с другой целью — проследовать в пункт его меню Правка -&gt; Источники приложений. Через него вызывается самостоятельная утилита фирменного набора, mintsources, она же software-sources (первое имя — символическая ссылка на второе). В разделе Администрирование главного меню ей соответствует пункт Источники приложений (это и есть официальное название программы, менеджер репозиториев — моя отсебятина, придуманная единообразия ради). Наконец, плюс к упомянутой возможности вызова software-sources из Менеджера программ, пиктограмма запуска её есть и в секции Администрирование Системных настроек Cinnamon.Вне зависимости от способа запуска, после ввода пароля открывается окно software-sources с пятью страницами, переключение между которыми осуществляется экранными кнопками. На первой странице, именуемой Официальные репозитории, выбираются зеркала двух основных репозиториев — собственного и репозитория Ubuntu (вся базовая часть Mint берётся из последнего). Здесь же отмечается, следует ли использовать бэкпорты, нестабильные пакеты, а также исходники:В списке зеркал обоих из основных репозиториев указываются их URL&#39;ы, флажок страны размещёния, а также реальная скорость соединения — последняя колонка появляется по прошествии некоторого времени, необходимого для получения соответствующих данных. Именно по скорости соединения список и сортируется, так что в обоих случаях следует просто выбрать верхнюю строку (в списке зеркал нет ни одного российского, так что выбор по «географическому» принципу смысла не имеет): Использование «обратно портированных» (backport) и нестабильных (romeo) пакетов разработчиками настоятельно не рекомендуется, и по умолчанию эти ветви репозиториев отключены. Попытка активировать любую из них вызывает предупреждение, для бэкпортов такое:А для нестабильных пакетов — такое:Не вижу оснований не прислушаться к этим предупреждениям — в любом случае, и к бэкпортам, и к нестабильным пакетам следует подходить индивидуально, а не устанавливать их все гуртом.Отключено также использование ветки репозитория, содержащей исходные тексты пакетов. Активация её не несёт никакой опасности, и потому не сопровождается предупреждением. Просто доступ к исходникам нужен далеко не всем применителям, а лишь тем, кто пересобирает пакеты с каким-либо своими специфическими опциями.Вторая страница — PPA-репозитории, то есть дополнительные PPA-репозитории из централизованного хранилища всех пакетов, собранных независимыми разработчиками и майнтайнерами:PPA-репозитории предназначены для Ubuntu и её прямых родственников (вроде Kubuntu и Xubuntu). Но, поскольку Mint с Ubuntu полностью обратно совместим, пакеты эти обычно (если не вообще всегда) можно использовать и в нём. По крайней мере, я не только не сталкивался с какими-либо проблемами, но и не слышал о таковых. Для доступа к PPA-репозиториям фирма Canonical разработала специальную систему с web-интерфейсом — Launchpad.Для подключения дополнительного репозитория его сначала нужно отыскать на Launchpad&#39;е и определить его ppa-имя. Например, для PPA-репозитория с пакетами поддержки файловой системы ZFS оно будет таким: ppa:zfs-native/stable. Затем кнопкой Добавить новый... вызывается панель, в соответствующее поле которой это имя вписывается:Нажатие кнопки OK вызывает панель с информацией о репозитории: И после подтверждения своих намерений новый репозиторий появляется в общем списке.В большинстве случаев при подключении PPA-репозиториев автоматически подключаются и их ветки с исходниками (в русском переводе почему-то называемые Источниками) .На странице Дополнительные репозитории аналогичную процедуру можно выполнить для репозиториев произвольных, в том числе и локальных:Страница Проверка подлинности ключей предназначена для хранения ключей к подключённым репозиториям — в большинстве случаев они вносятся в список автоматически:Наконец, на странице Maintenance можно произвести исправление проблем с локальными кешами пакетов, буде таковые возникнут (у меня пока не возникало) и их очистку от продуктов жизнедеятельности при установке пакетов:В правом верхнем углу окна программы можно видеть кнопку Обновить кэш. К ней следует обращаться после любых действий с репозиториями — это приведёт локальный кэш пакетов в актуальное состояние.Впрочем, не будет большого вреда нажать эту кнопку и в том случае, если никаких изменений в составе репозиториев не выполнялась — на всякий пожарный случай.Менеджер обновлений mintupdateПосле рассмотрения Менеджера программ и Менеджера репозиториев резонно перейти к средствам, обеспечивающим обновление системы. Таковым в фирменном наборе инструментов Mint является Менеджер обновлений — mintupdate. По умолчанию он включается в автозапуск, и потому применителю не нужно беспокоиться о его запуске: пиктограмма его сидит в трее, изменяя свой вид в зависимости от доступности обновлений: в виде буковки i на голубом фоне в случае их наличия, и в виде зелёной «галочки» — если система обновлений не требует. Соответствующие подсказки всплывают и при наведении курсора мыши на пиктограмму:При доступности обновлений получить визуальное представление о них можно, щёлкнув мышью на пиктограмме. После этого будет выведен список пакетов, которые могут быть обновлены в данный момент времени:Строго говоря, начиная с Mint 17.1, вывод не совсем попакетный: в одной строке списка может быть сгруппировано несколько родственных пакетов, которые друг без друга всё равно не устанавливаются, например — cinnamon и cinnamon-common. Эту группировку не следует путать ни с зависимостями, ни с метапакетами — она делается исключительно для компактности представления и лёгкости восприятия.Далее, некоторых пояснений требуют первые две колонки. Первая — тип обновления. Их два — стандартно обновляемые пакеты по выходе их новой сборки или версии (отмечены серой стрелкой) и обновления безопасности, ликвидирующие выявленные «дыры» в них (отмечены красным восклицательным знаком).Во второй колонке указывается уровень безопасности обновления пакетов. Здесь под безопасностью понимается не вероятность использования их злодеями, а то, как обновление пакета может повлиять на общую стабильность системы. Уровней безопасности в этом смысле пять:сертифицированные пакеты — обычно те, что непосредственно поддерживаются майнтайнерами Mint;рекомендуемые пакеты — проверены и одобрены разработчиками этого дистрибутива;безопасные пакеты — не проверялись разработчиками, но нарушение стабильности системы при их обновлении очень маловероятно;небезопасные пакеты потенциально могут повлиять на стабильность системы;опасные пакеты при некоторых условиях могут привести к нестабильности системы.Забегая вперёд, приведу скриншот окна настройки параметров Менеджера обновлений, наглядно иллюстрирующий сказанное:По умолчанию для обновления (третья колонка) отмечаются пакеты уровней 1-3. Для пакетов уровней 4-5 это нужно сделать принудительно. Если оно, конечно, нужно. Разработчики Mint считают, что решение об обновлении таких ключевых пакетов, как ядро, главная системная библиотека glibc и так далее, применитель должен принимать осознанно. Характерно, что режима автоматического обновления в Mint не предусмотрено как класса.Само по себе обновление выполняется нажатием экранной кнопки Установить обновления и начинается после ввода пользовательского пароля. Развернув пункт Show individual files, можно наблюдать за ходом процесса в деталях (если, конечно, больше заняться нечем): По завершении процесса окно обновлений предлагается закрыть:Как я уже говорил, Mint не предлагает автоматического обновления пакетов — Менеджер обновлений нужно запустить руками, или описанным выше способом, или из контекстного меню по щелчку правой кнопкой мыши на его пиктограмме в системной трее:Из него же можно получить доступ к настройкам mintupdate (пункт Параметры), о которых я скажу чуть позже, и к журналу обновлений (пункт Информация):Меню менеджера обновлений не дублирует кнопки на его панели инструментов. Через пункт меню Файл можно выйти из программы. Пункт Правка содержит подпункты Параметры — это настройка политики обновлений, до чего я скоро доберусь, и Источники приложений — это вызов того самого software-sources, о котором шла речь в предыдущем разделе. А в пункте Вид можно, во-первых, включить или отключить вывод каких-то колонок:Во-вторых, можно просмотреть историю обновлений:И в-третьих, можно получить информацию об установленном ядре и доступных для обновления версиях:Что такое Информация — я только что говорил. Так что можно вернуться в пункт Правка, где обратиться к подпункту Параметры. Скриншот первой вкладки вызываемого при этом окна я уже приводил, когда говорил об уровнях безопасности. Осталось только добавить, что здесь для пакетов 4-го и 5-го уровней можно включить отметку к обновлению «на постоянной основе». А можно сделать это для всех пакетов, обновляемых по типу обновления безопасности (другой, той, которая от злодеев).Во вкладке Автообновление задаётся время, через которое обновляется список пакетов. Подчеркну — именно их список сами по себе пакеты обновляться не будут, если не заказать это явным образом, как было сказано выше:Со вкладками Метод обновления и Игнорируемые пакеты всё понятно без комментариев: Вкладка Значки — это своего рода легенда (то есть условные обозначения): как выглядит пиктограмма Менеджера обновлений в зависимости от состояния системы и выполняемых им действий:Как и всякие условные обозначения, каждое из представлений пиктограммы можно изменить (только нужно ли?).На этом разговор о Менеджере обновлений считаю законченным. Следующим номером нашей программы будет рассказ о визуализаторах вывода.Средства визуализация пакетовВ качестве завершающего штриха в рассказе о mint-инструментах для работы с файлами скажу пару слов об утилитах mint-search-apt и mint-show-apt. Они предназначены для визуального представления результатов поиска пакетов и вывода информации о них. В сущности, это графические фронт-энды для вывода команд CLI apt search и apt show, соответственно (о которых будет в другом очерке). Подчеркну — именно вывода: сами эти утилиты запускаются из командной строки терминала или из минитерминала.Команда mint-search-apt в качестве аргумента принимает имя пакета или его фрагмент: поиск введённой последовательности символов осуществляется только в именах пакетов. После чего результат поиска выводится во вновь открывающемся окне. Например, ответ на команду$ mint-search-apt geanyбудет таким:Теоретически двойной клик на имени найденного пакета должен привести к его инсталляции. Однако в реальности последует лишь сообщение об ошибке:Утилита apt-cache show в качестве аргумента требует имени пакета, после чего в отдельном окне выводит информацию о нём. Например, после команды$ mint-show-apt geanyоно будет выглядеть следующим образом: Обе рассматриваемые утилиты входят в пакет mintinstall, который был разработан задолго до появления интегрированной команды apt, о которой будет говориться в очерке про пакетный менеджмент. И в те не столь далёкие времена их применение было оправдано. Ныне же, как мне кажется, использование их большого смысла не имеет. Хотя кому-то, может, и понравится вывод найденных пакетов и информации о них в графическом окне. Почему я и уделил им немного внимания.Этой заметкой завершается описание фирменных утилит Mint&#39;а, так или иначе связанных с управлением пакетами. Следующий раздел — о резервном копировании.Средство резервного копирования mintbackupОт средств работы с пакетами плавно переходим к средствам работы с файлами. А тут одно из наипервейших дел — резервное копирование. Для чего в составе фирменного инструментария Mint имеется утилита mintbackup. В разделе Администрирование главного меню она так и называется — Резервное копирование. И, после ввода пароля, предстаёт в таком вот виде:Для начала выполняется резервное копирование, для которого указываются исходный и целевой каталоги, а также дополнительные параметры — простое копирование, архив tar, tar.bz2 или tar.gz, условия перезаписи:Далее определяются исключения из исходного каталога, не подлежащие архивированию (если, конечно, они нужны):После этого выводится результирующая информация о будущем архиве: А затем нажатие кнопки Применить вызывает начало процесса:Завершение которого знаменуется таким сообщением:Здесь следует нажать кнопку Закрыть — правда, это приведёт и к закрытию программы, но выбора всё равно нет.То есть всё просто до банальности — и ничего такого, чего нельзя было бы сделать с помощью утилиты tar и её опций. Но всё это представлено в наглядной форме, избавляющей от необходимости ломать голову над последними. Иными словами, в этой своей части утилита mintbackup заслуживает рекомендации к применению.Не менее проста и полезна утилита mintbackup во второй своей части, сохраняющей список установленных пакетов. Здесь всего-то и требуется, что указать целевой каталог:Затем, при желании, просмотреть список пакетов, установленных в системе:После чего нажать кнопку Применить — и дождаться появления сообщения об успешном завершении процесса:После чего в целевом каталоге обнаруживается файл вида software_selection_alv-desk@2014-12-14-1850-package.list. Каковой является самым обычным текстовым файлом, содержащим список установленных пакетов:accountsservice installacl     installadd-apt-key     installadobe-flashplugin       installaisleriot       install...Пакеты по этому списку могут быть установлены на любой другой машине. Так что и от mintbackup нет никакого вреда, окромя пользы.Программа записи USB mintstickКак известно, оптические приводы постепенно отмирают. И на смену им приходят USB flash и SD-карты. Единственная сфера, где до некоторого времени оптические накопители были не всегда заменимы — это установка системы на чистую машину. Однако ныне все современные дистрибутивы Linux&#39;а или BSD-системы распространяются в виде так называемых гибридных образов, допускающих их запись на твердотельные носители. Что повлекло за собой появление большого числа программ, призванных выполнить эту процедуру.Имеется такая утилита и в составе фирменного инвентаря Mint&#39;а. Это mintstick, которая в главном меню находится в разделе Стандартные под именем Создание загрузочного USB-носителя. И после запуска предстаёт перед глазами применителя в таком виде:Дальнейшие действия очевидны: надо выбрать записываемый образ и указать, куда он должен быть записан (воткнутая флешка или SD-карта предлагается по умолчанию):После этого потребуется ввести пароль и подождать завершения процесса, о чем будет сообщено дополнительно:В поле Подробности будут указаны имена файла образа и целевого устройства:Всё. Можно либо повторить процедуру для другого образа или устройства, либо закрыть программу.Хотелось бы ещё проще? Не получится — проще уже некуда.Языковые настройки — mintlocaleВ очерке о настройках Cinnamon упоминался модуль Языки в секции Параметры его Системных настроек. И, поскольку он, собственно, принадлежит к семейству фирменных утилит Mint (под именем mintlocale), было обещано рассказать о нём в соответствующее время. Время это наступило.Модуль Языки можно запустить как из панели Системных настроек, так и из секции Параметры главного меню. Он выполняет двоякую функцию. Во-первых, здесь можно изменить собственно язык интерфейса и прочие параметры, объединяемые понятием locale (формат даты, представление чисел, единицы измерения etc.). При выборе русского в качестве языка инсталляции всё это будет русским Российским (интерфейс, разумеется, русифицируется в меру испорченности перевода): При желании или необходимости можно установить и более иные языки — список доступных превышает два десятка: Главная особенность нового языкового модуля (он появился в Mint 17.1) — разделение групп параметров Language и Region (в русском переводе — Язык и Область/Край, соответственно). Первая определяет переменные LANG и LC_TIME, то есть собственно язык интерфейса и местное время. Группа же параметров Region задаёт значения всех остальных локально-зависимых переменных — LC_NUMERIC, LC_MONETARY, LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT и LC_IDENTIFICATION (представление чисел, единица бабла, формат бумаги, и так далее).Разнесение переменных по группам может показаться спорным, как и его аргументация Клементом (типа специально для отъезжающих за границу). Однако сама по себе идея отделения языка интерфейса от прочего локально-зависимого хозяйства весьма здрава, особенно если язык этот — смесь нижегородского с оксфордским. Что же до местного времени... С каждым очередным самым последним переводом часов оно теряет всё больше смысла. Так что не пора ли жить по Гринвичу? Вполне реализуемо, как можно видеть на следующем скриншоте: Вторая функция mintlocale — определение так называемого метода ввода. Поддержка их также впервые появилась в Mint 17.1. Методы ввода (Input Method) — это системы обеспечения ввода символов, отсутствующих на клавиатуре от слова «вааще». Например, китайских иероглифов и символов всех генетически связанных с ними систем письма. И потому, конечно, жизненно необходимы жителям соответствующих стран.Однако мы, индоевропейцы, семиты, тюрки и многие другие, выступая как единый советский народ, не испытываем в них ни малейшей потребности. И потому то, что реально ни один метод ввода не включён (разработчики объясняют это недостатком сил), огорчать нас не должно. Напротив, скорее радовать. Ибо попытки майнтайнеров некоторых дистрибутивов включать поддержку какого-либо из этих методов (мне приходилось сталкивать с IBus), да ещё и по умолчанию, нам, применителям, не давало ничего, кроме лишних проблем.Менеджер драйверов и интегрированное видео AMDПоследний из фирменных инструментов Mint, о котором я хотел сказать пару слов — Менеджер драйверов, он же mintdrivers, предназначенный для управления проприетарными драйверами, например, для видеокарт. Правда, мой личный опыт общения с ним оказался неудачным, но это связано с моим «железом», а не собственно с программой. Так что просто опишу последовательность действий, проиллюстрировав её скриншотами.Запуск утилиты происходит из секции Администрирование главного меню, где она носит имя Менеджер драйверов. После чего на экране появляется (в моём случае с интегрированным процессорным видео Radeon HD 7500G) такая картинка:Представляется очевидным, что для установки проприетарного драйвера достаточно вместо первой строки отметить третью и нажать кнопку Применить изменения. Только я это сделал — как процесс пошёл: Шёл процесс довольно медленно, так как кроме собственно драйвера fglrx в ходе его устанавливались lib32gcc1, dkms и ещё куча зависимостей, а также регенерация /boot/initrd.img. По завершении всего этого исходная картинка приняла следующий вид:Заодно был создан и файл /etc/X11/xorg.conf с описанием конфигурации видеосистемы. Что в моём случае, правда, не помогло: после рестарта машина отказалась загружаться, выдав чёрный экран без возможности переключения в текстовую консоль и реакции на комбинацию из трёх пальцев. Пришлось перезагружаться в recovery mode и заниматься ликвидацией этого безобразия — но это совсем другая история.Впрочем, проделанный опыт не был совсем уж бесполезным. Оказалось, что теоретически установка проприетарных драйверов через штатный Менеджер драйверов действительно очень проста, хотя в дальнейшем не исключены осложнения — но они, повторяю, скорее всего связаны с особенностями «железа».На этом я пока поставлю точку в описании фирменного инструментария дистрибутива Mint. За бортом остались ещё несколько утилит, повода обращаться к которым у меня не было, и потому ничего сказать про них я не могу. В их числе:mintWifi — средство настройки соответствующего соединения; но у меня на Ноутбучке WiFi волшебным образом заработал сам собой, без всяких настроек;mintupload-manager — средство управления закачками на сервера, применения которому я не нашёл;mintnanny — блокировщик доменов; без надобности, ибо я не депутат госдумы, чтобы мне везде мерещилась банда педофилов с ихней порнографией.Что же до утилит mint-make, mint-batch-make, mint-compress, mint-decompress, о назначении которых можно догадаться по их именам, то к ним я обращусь, когда и если (если и когда) в этом возникнет практическая необходимость."
},




{
"title": "Прочие настройки",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca110_other_config.html",
"summary": "",
"body": "В предыдущих очерках говорилось о штатных инструментах для настройки дистрибутива Mint и его среды Cinnamon. Чтобы закончить с этой тему, скажу несколько слов об инструментах конфигурирования не то чтобы нештатных, но непосредственно ни к дистрибутиву, ни к среде не привязанных. И к которым приходится обращаться не так уж часто.Редактор dconfРедактор dconf появился в GNOME 3 и ныне применяется для низкоуровнего конфигурирования, кроме родительсккой среды, также в Unity, MATE и Cinnamon. Он позволяет напрямую редактировать всю базу конфигурации, как общесистемную, так и штатных пользовательских приложений. И, хотя делает это и не самым простым способом, но даёт доступ к тем настройкам, которые разработчики сред посчитали недостойными внимания конечных пользователей. Или, скорее, решили, что народу они не нужны.Правда, в Cinnamon таких замаскированных настроек очень мало. И если в Unity обращаться к Редактору dconf приходится постоянно, а в MATE — периодически, то в нашей среде у меня поводы для запуска этой утилиты возникали буквально считанные разы.Запускается эта утилита, кстати, через пункт Редактор dconf в секции Администрирование главного меню, после чего предстаёт в таком виде:Каждый пункт во фрейме слева разворачивается каскадом вложенных пунктиков и подпунктиков, имя которым далеко превышает легион. И описывать которые я не буду. А дам пару практических рецептов для включения некоторых опций, недоступных через Системные настройки среды Cinnamon.Ранее я упоминал, что в текущей версии Cinnamon возможность сохранения сеанса из пункта Автостарт изъята. Но в Редакторе dconf она осталась. И доступ к ней осуществляется по схеме org.cinnamon.SessionManager, где следует включить параметр (в терминологии dconf — ключ) auto-save-session:Не так давно мы весьма подробно рассмотрели конфигурирование раскладок клавиатуры и их переключателей через соответствующий модуль Системных настроек Cinnamon. И пришли к выводу, что тут можно настроить всё, что только душе угодно. Тогда же было упомянуто, что всё то же самое можно проделать и в Редакторе dconf. Для чего достаточно проследовать по org.gnome.libgnomekbd.keyboard и заполнить желаемым образом поля layouts, model и options:Как заполнить — описывать не буду, потому что через модуль Клавиатура в Системных настройках это сделать проще. А вот если пройти по схеме org.gnome.libgnomekbd.desktop, то можно включить ключ load-exta-items:Это обеспечит загрузку редко используемых раскладок клавиатуры. В частности, для русской раскладки окажутся доступными дополнительные варианты — те, что пыведены курсивом:В русскоязычном окружении этот ключ практического значения не имеет, но для всяких прочих языцей — может пригодиться. Например, для программирования на APL:Впрочем, более никаких практических задач для решения в Редакторе dconf я не придумал.Mint и консольВсё, что было сказано о конфигурировании Mint в предыдущих очерках, относилось к настройкам графических сред, даже конкретно одной представительницы их — Cinnamon. Но ведь в Linux&#39;е есть ещё и «текстовый» режим, то есть консоль. «Текстовый» в кавычках — потому что, конечно, чисто текстовой консоли нынче не найти, наверное, ни в одном дистрибутиве, везде frame buffer — но уж такова традиция.Любителей выполнять в «голой» консоли практическую работу нынче не так уж и много. Наверное, поэтому майнтайнеры практически всех дистрибутивов относятся к настройке консольного режима абы как, если не сказать — никак. А уж когда дело доходит до локализованных систем — это вообще туши свет. Редкий дистрибутив может похвастаться тем, что в его голой консоли в ответ на команду$ dateвыводятся настоящие русские буквы, а не квадратики или кракозябры.Повторяю, вряд ли кто будет сочинять в консоли многотомные романы на русском языке — в основном в текстовом режиме приходится загружаться при всякого рода сбоях. Но иногда приходится. Аварийные работы тоже лучше выполнять в комфортной и приятной для глаз обстановке. Да и вообще, как говорил штабс-капитан Мышлаевский, в казарме должен быть порядок, А текстовая консоль большинства современных дистрибутивов от порядка далека.К чести Mint надо сказать, что этот дистрибутив принадлежит как раз к тем редким, у которых консоль русифицирована «искаропки». Русские буквы здесь и правильно выводятся, и правильно вводятся. Причём вводятся в том самом варианте русской раскладки клавиатуры, который был задан при инсталляции системы, и переключатель раскладок (по комбинации Alt+Shift) оказывается таким же, как в графическом режиме. В общем, оказывается, что приложить руки к улучшательству есть где. Ибо у применителя всё должно быть прекрасно — в том числе и консоль.Особенно раздражает отсутствие поддержки мыши — без неё работа в консоли, даже аварийно-спасательная, становится мучительной. Ибо мышь в консоли — устройство не указательно-позиционирующее, а копировально-вставляющее. Достаточно выделить мышью фрагмент экрана, как он попадает в экранный буфер, откуда может быть вставлен в любое место, в том числе и в другую виртуальную консоль, щелчком средней кнопки мыши. Функция, незаменимая при правке конфигов — а ведь аварийно-спасательные работы обычно к ней и сводятся.Поясню (как ни странно, нынче это надо пояснять), что на современных колесовых мышах роль средней кнопки почти всегда выполняет это самое колёсико. А на ноутбучных тачпадах тот же эффект достигается одновременным нажатием обеих кнопок. Правда, что делать на входящих в моду ноутбуках с однокнопочными тачпадами — не знаю; разве что, не покупать их...Из поставленных задач по улучшательству консоли проще всего решается первоочередная — включение службы консольной мыши, сиречь gpm. Для этого нужно, как это ни парадоксально, установить пакет gpm:$ sudo apt install gpmЕсли сделать это, находясь в чистой консоли (а перключиться в любую из них можно по комбинации клавиш Control+Alt+F#, # — от 1 до 6; возврат в графический сеанс — Alt+F8), то немедленно после завершения установки можно будет увидеть курсор мыши в виде прямоугольничка. И теперь, по крайней мере, не придётся при всяких ремонтно-восстановительных работах вводить много лишних символов — в распоряжении применителя описанный выше «мышиный» буфер.Следующая задача на очереди — установка удобочитаемого экранного шрифта. Проще всего она решается утилитой dpkg-reconfigure. Вызванная в таком виде$ sudo dpkg-reconfigure console-setupона запустит псевдографическую программу, настройки экранных шрифтов для консоли. Которая сначала попросит выбрать кодировку:Затем спросит об используемой таблице символов:Потом последует предложение выбрать шрифт:Далее будет проведён маленький ликбез о консольных шрифтах и условиях их использования:Не советую им пренебрегать — после этого легче сделать осознанный выбор матрицы шрифта (типографские термины к консольным шрифтам не применимы):После этого происходит выход из интерфейса утилиты, и всё заказанное претворяется в действительность. Процесс этот связан с регенерацией initrd, так что его результат можно будет увидеть только после рестарта — с которым, впрочем, не обязательно торопиться.Третья задача очень важна для меня — но возможно, что большинству применителей решать её не придётся. Я использую сочетание варианта Typewriter Legacy для кириллической раскладки и CapsLock в качестве переключателя латиница/кириллица. Когда-то эта была стандартная комбинация (именно такова была первая русская раскладка для UNIX-косоли, созданная Андреем Черновым aka ache), но ныне воспринимается как экзотика. И её «спаривание» для консоли Linux требует некоторых усилий. В частности, в большинстве дистрибутивов мне приходилось прибегать к раскладке, изготовленной собственноручно.А вот в Mint эти усилия минимальны. Я имел не один раз повод радостно сообщить, что выбранная при установке раскладка клавиатуры и один из её вариантов (среди которых имеется и Typewriter Legacy) наследуется не только Иксами, но и консолью установленной системы. Правда, с переключением раскладок по Alt+Shift, порождённым каким-то умником в недрах Microsoft&#39;а вместе с раскладкой winkeys (также одной из самых неудобных, какую только можно придумать).Однако задача с изменением переключателя решается очень просто: достаточно отредактировать файл /etc/default/keyboard. Он практически точно совпадает с клавиатурной секцией старого /etc/X11/xorg.conf или современного /etc/X11/xorg.conf.d/10-keymap.conf, и по умолчанию выглядит так:XKBMODEL=&quot;pc105&quot;XKBLAYOUT=&quot;us,ru&quot;XKBVARIANT=&quot;,typewriter-legacy&quot;XKBOPTIONS=&quot;grp:alt_shift_toggle,grp_led:scroll&quot;Так что в нём достаточно заменить значение переключателя alt_shift_toggle на желаемое, например, для меня — на caps_toggle. После чего можно с чистым сердцем перегружаться и, авторизовавшись в любой текстовой консоли, любоваться красивыми шрифтами семейства Terminus, созданными Димитром Жековым, набирать русские буквы в привычной раскладке и, при необходимости, копировать набранное из консоли в консоль через «мышиный» буфер.GRUB2: восстановление загрузчикаВ заключение всей «конфигурационной солянки» — пара слов о загрузчике GRUB2. Материалов в Сети на эту тему немерянно (одним из самых полезных мне представляется вот этот), и пересказывать их я не намерен. А остановлюсь только на восстановлении загрузчика в случае его порчи по каким-либо причинам.Есть несколько методов восстановления GRUB2, я опишу тот, который представляется мне самым простым.Для начала надо иметь Live-носитель Mint в любом виде — DVD-, флешки, SD-карты, каковой помещается куда следует. При рестарте машины, обычно в момент появления логотипа производителя, нужно успеть нажать клавишу быстрого выбора загрузочного устройства — для современных ASUS&#39;овских «матерей» это F8, для ASRock&#39;овских — F11, для прочих — см. документацию. И в появившемся меню выбрать нужный пункт, он обычно называется явным образом. Происходит загрузка Live-среды, каковая в нашем случае представлена Mint с Cinnamon-окружением.Далее следует опознать имя файла устройства, несущего корневой раздел системы, загрузчик которой подлежит восстановлению — подчёркиваю, требуется имя устройства, а не раздела. Это можно сделать просмотром вывода либо команды$ sudo fdisk -lлибо команды$ ls /dev/sd*Предположим для определённости, что это устройство /dev/sda. Теперь корневой раздел монтируется в файловую систему Live-среды. Прще всего сделать это через Nemo — в его боковой панели, в секции Носители, отражаются все присутствующие в машине дисковые устройства. И достаточно выбрать пункт Присоединить контекстного меню или просто «левокликнуть» на соответствующем имени. Теперь главное — определить точку монтирования. В Mint (как и во всех Ubuntu&#39;идах) временно смотированные устройства попадают в каталог /media/username, устройства с меткой — в подкаталог с её именем, без оной — в подкаталог с универсальным идентификатором устройства (UID), это полуметровая зубодробительная последовательность букв и цифр.А вот теперь — собственно восстановление загрузчика. Оно выполняется одной командой:$ sudo grub-install --root-directory=/media/username/mount_point /dev/sdaЗдесь mount_point — метка диска или его очень простой UID вроде d55aebcb-7e7d-4d34-aff4-ed6e494e9b7f. Автодополнение в этом случае не работает, однако, даже если устройство не «помечено», его UID можно взять из файла /etc/mtab, описывающего временно смонтированные устройства, или, открыв его в Nemo, из адресной строки последнего.На этом дело восстановления загрузчика закончено — можно перезагружаться в нормальном режиме."
},




{
"title": "Основы командного интерфейса",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebecca120_cli_base.html",
"summary": "",
"body": "Поскольку не исключена вероятность, что эту книгу будут читать и совсем начинающие применители Linux&#39;а вообще, тех, для кого Mint оказался первым дистрибутивом этой операционной системы, в этом очерке будут даны некоторые общие сведения об интерфейсе командной строки (CLI — Command Line Interface). Тем более, что это потребуется уже ближайшее время, в очерках, посвящённых управлению пакетами.Введение в CLICLI представляет собой базу, для которой GUI всякого рода являют лишь оболочку. Всякое действие в linux-системе может быть выполнено прямой командной директивой. И его же можно осуществить путем манипулирования объектами. Например, копирование файлов выполняется соответствующей командой — cp, это первый способ. Но его же можно осуществить перетаскиванием мышью объекта, представляющего наш файл зрительно, из того места, где он находился ранее, туда, где мы хотим видеть его копию, а это уже второй способ.То есть манипуляция объектами в GUI — это обычно более или менее опосредованное выполнение соответствующих данному действию команд. Почему основные навыки работы с CLI не помешают даже тому пользователю, который не вылезает из графической среды. Ибо сфера применения CLI не ограничивается «голой» консолью. Он же используется в эмуляторах терминала в графическом режиме оконной среды X. Более того, в настоящее время это основная среда для применения командного интерфейса — к текстовой консоли обычно обращаются только в аварийных ситуациях.CLI в большинстве случаев обеспечивается классом программ, именуемых командными интерпретаторами, командными процессорами, командными оболочками или по простому шеллами (shell).Как легко догадаться по одному из определений, кроме предоставления пользовательского интерфейса, шеллы выполняют и вторую функцию — служат интерпретаторами собственных языков программирования. На этом основывается классификация шеллов — они разделяются на две группы, обычно именуемые Bourne-shell совместимые и C-shell совместимые. В силу ряда причин в качестве стандарта принята одна из оболочек первой группы — так называемый POSIX-шелл. Правда, он представляет собой чистую абстракцию, однако большинство используемых в Unix&#39;ах оболочек с этим стандартом совместимы. А системная оболочка Mint, Dash, довольно точно воспроизводит и его функциональность. И потому все примеры, иллюстрирующие принципиальные вопросы CLI, будут базироваться на наиболее используемых командах, построенных в соответствие с правилами POSIX-шелла.Командная строкаОсновой командного интерфейса является командная строка, начинающаяся с приглашения для ввода. Далее он будет обозначаться милым сердцу россиянина символом длинного зеленого друга — $, если речь идёт о сеансе обычного пользователя, или символом решётки — #, для приглашения строки в сеансе администратора. Это — чистая условность: вид приглашения может быть настроен в широких пределах, причём по разному в разных оболочках. Об этом мы поговорим, когда речь дойдёт до описания конкретного шелла — Zsh.Командная строка — визуальное представление среды, в которой задаются основные элементы командного интерфейса: командные директивы с их аргументами и опциями.Командная директива (или просто команда) — основная единица, посредством которой пользователь взаимодействует с шеллом. Она образуется по определенным правилам, именуемым синтаксисом. Синтаксис командной директивы определяется, в первую очередь, языком, принятым в данной командной оболочке. Кроме того, некоторые команды (не очень многочисленные, но весьма употребимые) имеют собственный, нестандартный синтаксис.Однако в целом базовые правила построения команд имеют много общего. И именно эти базовые правила станут предметом данного раздела. Синтаксические особенности отдельных нестандартных команд будут оговариваться по ходу изложения.Итак, командная директива образуется:именем команды, однозначно определяющим ее назначение,опциями, определяющими условия выполнения команды, иаргументами — объектами, над которым осуществляются действия.Очевидно, что имя команды является обязательным компонентом, тогда как опции и аргументы могут и отсутствовать (или подразумеваться в неявном виде по умолчанию).ещё один непременный компонент командной директивы — это специальный невидимый символ конца строки: именно его ввод отправляет команду на исполнение. В обыденной жизни этот символ вводится нажатием и отпусканием клавиши Enter. Почему обычно и говорят: для исполнения команды нажмите клавишу Enter. Тот же эффект, как правило, достигается комбинацией клавиш Control+M. Символа конца командной строки, знаменующего исполнение команды, мы на экране не видим. Однако важно, что это — такой же символ, как и любой другой (хотя и имеющий специальное значение).В подавляющем большинстве случаев опции (или их последовательности) задаются непосредственно за именем команды, а аргумент (или группа аргументов) команду завершает, хотя это правило имеет некоторые исключения. Вне зависимости от порядка опций и аргументов, принятых для данной команды, интерпретация их осуществляется слева направо.Команды, опции и аргументы обязательно разделяются между собой пробелами. Кроме того, опции обычно предваряются (без пробела) символом дефиса или двойного дефиса. Впрочем, немногочисленные (но весьма употребимые) команды могут использоваться с опциями без всяких предваряющих символов.Как уже говорилось, имя команды определяет выполняемые ею функции. Существуют команды, встроенные в оболочку, то есть не имеющие запускающих их исполняемых файлов, и команды внешние. В последнем случае имя команды однозначно указывает на имя исполняемого файла программы, выполняемой при отдаче соответствующей директивы. Часто встроенные и внешние команды одного назначения имеют одинаковые имена. В этом случае обычно предпочтительно использование встроенных команд — впрочем, они и вызываются в первую очередь. Для вызова одноимённой внешней команды её нужно задать с указанием пути. Так, директива$ time search for Mint in path2/вызовет для определения времени выполнения команды search (о ней будет рассказываться в следующем очерке) встроенную команду time. А в форме$ /usr/bin/time search for Mint in path2/будет задействована внешняя утилита с тем же именем. Кстати, это один из тех случаев, когда второй вариант может иногда оказаться предпочтительней: встроенная и внешняя команды имеют разные форматы вывода, причём в первой он зависит от используемой командной оболочки. И потому она не всегда подходит для прямого сравнения результатов — например, быстродействия в разных системах.Определить, является ли данная команда встроенной в оболочку или внешней, можно с помощью встроенных команд type или which. Для встроенных команд вывод их будет таким:$ type whichwhich is a shell builtin$ which typetype: shell built-in commandИли, в некоторых случаях, таким:$ which timetime: shell reserved word$ type timetime is a reserved wordДля внешних команд любой из этих вариантов даст в выводе путь к исполняемому файлу:$ which date/bin/date$ type date/bin/dateНекоторые команды могут выступать под несколькими именами. Это связано с тем, что исторически в различных Unix-системах команды, исполнявшие одинаковые функции, могли получать разные названия. В каждой конкретной системе обычно используется только одна из таких команд-дублеров. Но при этом имена дублирующих команд также могут присутствовать в системе — для совместимости. Не следует думать, что это две различные программы одного назначения: как правило, такая синонимичность команд реализуется посредством механизма ссылок (links) или псевдонимов (alias), о которых речь пойдёт позднее.Иногда команда, вызванная через имя своего синонима, может отличаться по своей функциональности от самой же себя, вызванной под родным именем. В этом случае говорят о эмуляции одной команды другой. Типичный пример — командная оболочка /bin/bash в большинстве дистрибутивов Linux имеет своего дублера — /bin/sh; вызванная таким образом, она воспроизводит базовую функциональность стандарта POSIX-шелла.АвтодополнениеДля правильного применения команд, конечно же, нужно знать их имена и назначение. Однако нас никто не заставляет напрягать пальцы вводом имени команды полностью. Потому что тут на помощь приходит великий метод автодополнения.Благодаря этому методу для любой команды достаточно ввести первые несколько ее символов — и нажать клавишу табуляции (Tab). И, если введённых буковок достаточно для однозначной идентификации, полное имя команды волшебным образом возникнет в строке. Если же наш ввод допускает альтернативы продолжения имени — все они высветятся на экране (сразу или после повторного нажатия на табулятор), и из них можно будет выбрать подходящую.Большинство употребимых команд POSIX-систем — коротки и мнемонически прозрачны. И может показаться. что не такое уж это облегчение — заменить ввод двух-трех символов нажатием табулятора (а то ещё и неоднократным). Однако, когда речь дойдет до аргументов команд — тут вся мощь автодополнения станет явной.И ещё маленькое отступление. Автодополнение — стандартная возможность Bash и всех других командных оболочек, относимых к категории развитых. Но как раз в стандарте POSIX эта возможность не предусмотрена, и потому POSIX shell ее лишён. Нет этой функции и в Dash — системной командной оболочке Mint. Которая, впрочем, в интерактивном режиме не используется.Ещё один способ облегчения ввода команд — обращение к их истории, о чём разговор будет несколько позже.ОпцииУказания только имени команды достаточно для выполнения некоторых из них. Типичный пример — команда ls (от list), предназначенная для просмотра имен файлов (строго говоря, содержимого каталогов). Данная без аргументов, она выводит список имен файлов, составляющих текущий каталог, представленный в некоторой форме по умолчанию, например, в домашнем каталоге пользователя это будет выглядеть примерно так:$ lsDesktop/    Downloads/   Music/  Pictures/  Templates/Documents/  lost+found/  mytmp/  Public/    Videos/Исполнение же многих других команд невозможно без указания опций и (или) аргументов. Для них в ответ на ввод одного её имени часто следует не сообщение об ошибке (или не только оно), но и краткая справка по использованию команды. Например, в ответ на ввод команды для создания каталогов mkdir (от make directory) последует следующий вывод:usage: mkdir [-pv] [-m mode] directory ...Для одних опций достаточно факта присутствия в командой директиве, другие же требуют указания их значений (даваемых после опции обычно через знак равенства). В приведённом примере команды mkdir к первым относятся опции -v (или --verbose), предписывающая выводит информацию о ходе выполнения команды (запомним эту опцию — в том же смысле она используется чуть ли не во всех командах Unix), и -p, которая позволяет создать любую цепочку промежуточных каталогов между текущим и новообразуемым (в случае их отсутствия).А вот опция -m, определяющая атрибуты доступа к создаваемому каталогу, обязательно требует указания значения — этих самых атрибутов, заданных в символьной форме.Многие опции имеют две формы — краткую, односимвольную, и полную, или многосимвольную, Некоторые же опции могут быть даны только в многосимвольной форме. Общее правило здесь таково: если одного символа достаточно для однозначного определения опции, могут употребляться обе формы в качестве равноправных. Однако поскольку количество символов латинского алфавита ограниченно (а человеческая фантазия, конструирующая опции — безгранична), при большом количестве опций одной команды некоторые из них приходится делать исключительно многосимвольными.Продемонстрирую это на примере опций все той же команды mkdir. Полный их список будет следующим:-m, --mode=MODE установить код доступа        (как в chmod)-p, --parents не выдавать ошибок,        если существует, создавать        родительские каталоги,        если необходимо-v, --verbose печатать сообщение        о каждом созданном каталоге--help показать помощь и выйти--version  вывести информацию        о версии и выйтиОчевидно, что для опции --version краткая форма совпала бы с таковой для опции --verbose, и потому первая существует только в полной форме. А вот для опции --help краткая форма в большинстве команд возможна, и она выглядит как -h. Более того, во многих командах вызов помощи может быть вызван посредством опции -?. К слову сказать — приведенный выше список опций команды mkdir получен именно таким способом.Раз уж зашла речь об опциях --version и -h (--help, -?), давайте и их запомним на будущее. Это — так называемые стандартные опции GNU, в число коих входит и опция -v, --verbose. Назначение «длинной» их формы (--version, --help, --verbose) идентично почти во всех командах, краткой — во многих.Опять-таки, из того же примера видно, что опции в односимвольной форме предваряются единичным символом дефиса и могут быть даны единым блоком, без пробелов:$ mkdir -vpm 777 dir/subdirПри этом, естественно, опция, требующая указания значений, ставится последней, и ее значение отделяется пробелом. Опции же в многосимвольной форме требуют предварения удвоенным дефисом, обязательно должны разделяться пробелами и значения их, если таковые требуются, присваиваются через символ равенства (по научному он называется ещё оператором присваивания):$ mkdir --parents --mode=777 dir/subdirЗагадочные семерки после опции -m (--mode) — это и есть те самые атрибуты доступа, данные в символьной нотации, о которых речь пойдёт в соответствующем разделе.Опции команды именуются также флагами (реже ключами) или параметрами. Однозначной трактовки этих терминов нет. Однако обычно под флагами подразумеваются опции, не требующие указания значений. Термин параметр же применяется к опции, такового требующей, и объединяет опцию и ее значение. Правда, мне встречалось определение параметра как совокупности опций и аргументов, но я буду придерживаться приведенных определений.Порядок опций, если их приводится более одной, для большинства команд не существенен. Хотя, например, для команды tar, создающей файловые архивы, опция -f, значением которой является имя создаваемого или распаковываемого архива, традиционно указывается последней. И, к слову сказать, именно эта команда — одна из немногих, опции которой не обязаны предваряться символами дефиса. Так, директивы$ tar cf filename.tar dirи$ tar -cf filename.tar dirабсолютно равноценны: и та, и другая создает единый архивный файл filename.tar из отдельных файлов каталога dir.Особый смысл имеет символ удвоенного дефиса --, если после него не следует никакой опции: таким образом обозначается конец списка опций, и все последующие, отделённые пробелом, символы интерпретируются как аргументы. Одинарный же дефис с последующим пробелом, напротив, подменяет аргументы команды, то есть в качестве таковых рассматривается стандартный ввод: знание этого нам потребуется, когда речь дойдёт до командных конвейеров.Пример: опции команды lsОпции определяют условия выполнения команды. На предыдущей странице был приведён пример команды ls без опций. Однако на самом деле отсутствием опций при ней определяется вид выводимого списка по умолчанию — как многоколочночного списка, состоящего из имен файлов без учета т.н. скрытых файлов (а таковыми являются файлы, имена которых начинаются с символа точки, почему они ещё называются dot-файлами), без каких-либо их атрибутов и без визуального различия файлов различных типов.Различные же опции команды ls определяют состав и формат выводимого списка файлов. Так, в форме$ ls -aона обеспечивает вывод списка имен всех файлов текущего каталога, включая скрытые файлы вида .* (символ * здесь обозначает шаблон имени, соответствующий любому количеству любых символов — в том числе и нулевому, то есть отсутствию оных), символы текущего (./) каталога и каталога родительского (../).В форме$ ls -lдается вывод списка имен файлов в «длинном» формате (отсюда название опции -l — от long), то есть с указанием атрибутов доступа, принадлежности, времени модификации, размера и некоторых других характеристик:drwxrwxr-x. 14 alv alv 4,0K Мар 14 08:40 current/drwxr-xr-x.  2 alv alv 4,0K Фев  8 11:28 Desktop/drwx------.  5 alv alv 4,0K Мар 11 18:34 priv/Форма$ ls -Fпозволяет получить список файлов с символьным различением файлов различных типов. Например, имя каталога будет выглядеть как dirname/, имя исполнимого файла — как filename* (здесь звездочка — не шаблон имени, а символическое обозначение исполняемого файла), и так далее.Я столь подробно остановился на команде ls не только из-за многочисленности ее опций: это — одна из самых употребимых команд для просмотра файловой системы. И, должным образом настроенная (в том числе и с помощью приведенных опций), она дает ничуть не менее информативную и зрительно выразительную картину, чем развитые файловые менеджеры типа Midnight Commander или многочисленные файловых менеджеры графического режима.АргументыТаким образом мы подобрались к понятию аргументов командной директивы. Аргументами определяется, как правило, объект (или объекты) действия команды. В большинстве случаев в качестве аргументов команд выступают имена файлов и (или) пути к ним.Выше говорилось, что при отсутствии аргументов команда ls выводит список имен файлов текущего каталога. Это значит, что текущий каталог выступает как заданный неявным образом (по умолчанию) аргумент команды ls. Если же требуется вывести список имен файлов каталога, отличного от текущего, путь к нему должен быть указан в качестве аргумента команды явно, например:$ ls /usr/binБольшинство команд допускает указание не одного, а нескольких (и даже очень многих) аргументов. Так, единой директивой вида$ cp file1 file2 ... fileN dirможно скопировать (команда cp — от copy) сколько угодно файлов из текущего каталога в каталог dir (на самом деле на это «сколько угодно» накладываются некоторые теоретические ограничения, определяемые максимально возможной длиной командной строки, но практически предел этот очень далек).Маленькое отступление. Упоминание команды cp — удобный случай чуть вернуться назад и рассмотреть одну очень важную опцию, почти универсальную для команд POSIX-систем. Для начала попробуем скопировать один каталог в другой:$ cp dir1 dir2Как вы думаете, что получится в результате? Правильно, сообщение о невозможности выполнения этой операции — примерно в таком виде:cp: omitting directory &#39;dir1&#39;поскольку команда cp в чистом виде для копирования каталогов не предназначена. Что делать? Очень просто — указать опцию -R (от Recursive; в большинстве систем проходит и опция -r с тем же смыслом, но первая форма работает абсолютно везде. В результате в каталог dir2 не только будут скопированы сам каталог dir1 и все входящие в него файлы, но и вложенные подкаталоги из dir1, если таковые имеются.Маленькое уточнение: вполне возможно, что в дистрибутиве, который имеется в вашем распоряжении, проходит и копирование каталогов просто через cp, без всяких дополнительных опций. Это — потому, что команда cp часто определяется как псевдоним самой себя с опцией рекурсивного копирования, о чем скоро пойдет речь.Вообще рекурсия (то есть определение некоего выражения через самого себя) — очень важное понятие в Unix, пронизывающее происходящие от нее системы насквозь. И послужившие даже базой для своеобразного хакерского юмора. Однако сейчас для нас важно только то, что рекурсия применима практически ко всем файловым операциям, позволяя распространить действие одной командной директивы не только на файлы данного каталога, но и на все вложенные подкаталоги и их содержимое.Однако вернемся к аргументам. Действие некоторых команд неоднозначно в зависимости от аргументов, к которым она применяется. Например, команда mv служит как для переименования файлов, так и для их перемещёния в другой каталог. Как же она узнает, что ей делать в данном конкретном случае? Да именно по аргументам. Если дать ее в форме$ mv filename1 filename2то следствием будет переименование filename1 в filename2. А вот если первым аргументом указан файл, а вторым — каталог, например$ mv filename dirто результатом будет перемещёние filename из текущего каталога в каталог dir. К слову сказать, команды типа mv воспринимают разное количество аргументов в зависимости от того, какие они, эти аргументы. В первом примере аргументов может быть только два — имя исходного файла и имя файла целевого. Зато во втором примере в качестве аргументов можно задать сколько угодно файлов и каталогов (с учетом вышеприведенной оговорки относительно «сколько угодно») — все они будут перемещёны в тот каталог, который окажется последним в списке. То есть директивой:$ mv file1 ... fileN dir1 ... dirM dirNв каталог dirN будут перемещёны все файлы file1 ... fileN и все каталоги dir1 ... dirM. Характерно, что для этого команде mv, в отличие от команды cp, ей не требуется каких-либо дополнительных опций — она рекурсивна по самой своей природе.Пути к файламДля правильного построения аргументов команды требуется рассмотрение ещё одного понятия — пути к файлу. Путь — это точное позиционирование файла в файловой системе относительно ее корня (обозначаемого символом прямого слэша — /) или нашего в ней положения — текущего каталога (который, напомню, символически обозначается единичной точкой — .).Так, если пользователь находится в своем домашнем каталоге (абсолютный путь к нему обычно выглядит как /home/username), то просмотреть содержимое каталога /usr/bin он может двумя способами — тем, который был дан в предыдущем примере, или вот так:$ ls ../../usr/binПервый путь в аргументе команды ls — абсолютный, отсчитываемый от корневого каталога, второй — задается относительно каталога текущего, ведь ../ — это родительский каталог для него.Пути в аргументах команд могут быть весьма длинными. Например, чтобы просмотреть список шрифтов, применяемых в интерфейсе Cinnamon по умолчанию, нужно дать команду следующего вида:$ ls /usr/share/fonts/truetype/notoИ читатель вправе спросить — неужели мне все это вводить вручную? Отнюдь — отвечу я ему. Потому что автодополнение, о котором упоминалось по ходу разговора об именах команд, действует также для путей в их аргументах — последовательным нажатием клавиши табуляции все недостающие символы будут добавлятьсяЕщё один способ избежать набора длинных путей к файлам — это определение переменной PATH. Внимательный читатель, вероятно, обратил внимание, что при наборе команды путь к исполняемому её файлу не указывается. Для внутренних команд причина понятна — они прошиты в самой оболочке. А как мы обходимся без указания путей к командам внешним? Неужели система мистическим чувством определяет, где они находятся?Отнюдь, ни малейшей мистики, Просто каталоги, в которых находятся команды (а это, как правило, /bin, /sbin, /usr/bin, /usr/sbin) определены в качестве значений переменной PATH, о чём мы подробнее поговорим со временем.Кое-что об исключенияхИтак, типичная форма POSIX-команды в обобщенном виде выглядит следующим образом:$ command -[options] [arguments]Из этого правила выбиваются немногочисленные, но весьма полезные и часто используемые команды. Однако и для таких команд с нестандартным синтаксисом устанавливаются те же компоненты — имя, опции, аргументы, хотя по ряду причин (в том числе исторических) порядок их может меняться.Это можно проиллюстрировать на примере полезнейшей команды find, предназначенной для поиска файлов (и не только для этого — она являет собой почти универсальное орудие в деле всякого рода файловых манипуляций). В типичной своей форме она выглядит примерно следующим образом:$ find dir -option1 value -option2 [value]Здесь dir — каталог, в котором выполняется поиск, — может рассматриваться в качестве аргумента команды. Опция -option1 (обратим внимание, что здесь, не смотря на многосимвольность опций, они предваряются единичным символом дефиса) и ее значение value определяют критерий поиска, например, -name filename — поиск файла с указанным именем, а опция -option2 предписывает, что же делать с найденным файлом (файлами), например, -print — вывести его имя на экран. причём опция действия также может иметь значение. Например, значением опции -exec будет имя команды, вызываемой для обработки найденного файла (файлов). Так, директива вида$ find ~/ -name *.tar -exec tar xf {} ;требует отыскать в домашнем каталоге (~/), выступающем в качестве аргумента, файлы, имя которых (первая опция — критерий поиска) соответствует шаблону *.tar (значение первой опции), и выполнить (вторая опция — действия) в их отношении команду tar с собственными опциями, обеспечивающими распаковку архивов (значение второй опции). Интересно, что в этом контексте в качестве значений второй опции команды find выступает не только внешняя команда, но и все относящиеся к ней опции.В последнем примере имеется несколько символов, смысл которых может показаться непонятным. Надеюсь, он прояснится достаточно скоро — в разговоре о регулярных выражениях.ПсевдонимыВернемся на минуту к команде ls. У читателя может возникнуть вполне резонный вопрос: а если я всегда хочу видеть ее вывод с символическим различением типов файлов, да ещё в «длинном» формате? Ну и без вывода скрытых файлов мне никак не прожить. И что же — мне каждый раз вводить кучу опций, чтобы получить столь элементарный эффект?Отнюдь — ответил бы граф, стуча манжетами о подоконник. Потому что этот вопрос задавали себе многие поколения не только пользователей, но и разработчиков. И ответили на него просто — введением понятия псевдонима команды (alias).Что это такое? В большинстве случаев — просто некоторое условное имя, подменяющее определённую команду с теми её опциями, которые мы используем чаще всего. Причём, что характерно, псевдоним команды может совпадать с ее именем. То есть, например, — набирая просто ls, мы получаем список файлов не в умолчальном формате, а в том, в каком угодно нам.Устанавливаются псевдонимы очень просто — одноименной командой alias, в качестве аргументов которой выступают имя псевдонима и его значение, соединенные оператором присваивания (именуемым в просторечии знаком равенства). А именно, если мы хотим ныне, и присно, и во веки веков видеть вывод команды ls с символьным различением типов файлов, нам достаточно дать команду вроде следующей:$ alias ls=&#39;ls -FЗдесь следует обратить внимание на два момента: а) на то, что имя псевдонима совпадает с именем команды (что отнюдь не препятствует создания псевдонима типа ll=&#39;ls -l&#39; специально для вывода файловых списков в длинном формате), и б) на одинарные кавычки, в которые заключено значение псевдонима. Смысл их станет ясен несколькими параграфами позже, а пока просто запомним, что кавычки (и именно одинарные) — обязательный атрибут команды установки псевдонима.Таким образом мы можем наделать себе псевдонимов на все случаи жизни. В разумных пределах, конечно — иначе вместо упрощения жизни мы создадим себе необходимость запоминания множество невнятных сочетаний символов. Однако на наиболее важных (и обычно определяемых) псевдонимах я остановлюсь.Вспомним команды типа cp и mv, которыми мы, в частности, можем скопировать или переместить какие-то файлы из каталога в каталог. А что произойдет, если чисто случайно в целевом каталоге уже имеются файлы, одноименные копируемым/перемещаемым? Произойдет штука, могущая иметь весьма неприятные последствия: файлы в целевом каталоге будут заменены новыми, теми, что копируются туда или перемещаются. То есть исходное содержание этих файлов будет утрачено — и безвозвратно, восстановить его будет невозможно никакими силами.Разумеется, иногда так и нужно, например, при полном резервном копировании старые версии файлов и должны быть заменены их более свежими вариантами. Однако такое приемлемо далеко не всегда. И потому в большинстве команд, связанных с необратимыми изменениями файловой системы, предусматривается специальная опция — -i (или --interactive). Если задать эту опцию с командой cp или mv, то при совпадении имён исходного и целевого файлов будет запрошено подтверждение на выполнение соответствующего действия:$ cp file1 file2cp: overwrite  file2&#39;?И пользователь может решить, нужно ли ему затирать существующий файл, ответив yes (обычно достаточно y), или это нежелательно, и должно ответить no (а также просто n — или не отвечать ничего, это равноценно в данном случае отрицательному ответу).Так вот, дабы не держать в голове необходимость опции -i (ведь, как я уже говорил, пропуск ее в неподходящий момент может привести к весьма печальным результатам), в подавляющем большинстве систем для команд cp и mv (а также для команды rm, служащей для удаления файлов — эта операция также практически необратима) определяются одноименные им псевдонимы такого вида:$ alias cp=&#39;cp -i&#39;;$ alias mv=&#39;mv -i&#39;;$ alias rm=&#39;rm -i&#39;Все это, конечно, очень благородно, заметит внимательный читатель. Но что, если мне заведомо известно, что сотни, а то и тысячи файлов целевого каталога должны быть именно переписаны новыми своими версиями? Что же, сидеть и, как дурак, жать на клавишу Y?Не обязательно. Потому что все команды рассматриваемого класса имеют ещё опцию -f (в «длинной» своей форме, --force, она также практически универсальна для большинства команд). Которая, отменяя действие опции -i, предписывает принудительно переписать все файлы целевого каталога их обновленными тезками. И никто не мешает нам на этот случай создать ещё один псевдоним для команды cp, например:$ alias cpf=&#39;cp -f&#39;Правда, предварительно нужно убедиться, что в системе нет уже команды с именем, совпадающим с именем псевдонима — иначе эффект может быть весьма неожиданным (впрочем, это относится ко всем псевдонимам, не совпадающим с именами подменяемых команд).Есть и другой способ обойти опции, установленные для команды-псевдонима: просто отменить псевдоним. Что делается командой обратного значения$ unalias alias_nameТо есть дав директиву$ unalias cpмы вернем команде копирования ее первозданный смысл. Ну а узнать, какие псевдонимы у нас определены в данный момент, и каковы их значения, ещё проще: команда$ aliasбез опций и аргументов выведет полный их список:la=&#39;ls -A&#39;less=&#39;less -M&#39;li=&#39;ls -ial&#39;ll=&#39;ls -l&#39;ls=&#39;ls -F --color=auto&#39;и так далее.Когда я сказан о пользовании псевдонимами ныне, и присно, и вовек, — то был не совсем точен. Ныне, то есть в текущем сеансе пользователя — да, они работают. Однако после рестарта системы (или просто после выхода из данного экземпляра командной оболочки) они исчезнут без следа. Чтобы заданные псевдонимы увековечить, их нужно прописать в конфигурационном файле пользовательского шелла. Но этим мы займемся впоследствии. А пока обратимся к переменным.ПеременныеПеременные играют для аргументов команд примерно такую же роль, что и псевдонимы — для команд. То есть избавляют от необходимости мрачного ввода повторяющихся последовательностей символов. Конечно, это — далеко не единственное (а может быть, и не главное) назначение переменных, однако на данном этапе для нас наиболее существенное.Что такое переменная? Ответ просто — некоторое имя, которому присвоено некоторое значение. Не очень понятно? — Согласен. Но, возможно, станет яснее в дальнейшем.Имена переменных в принципе могут быть любыми, хотя некоторые ограничения также существуют. Я уже вскользь упоминал о переменных в разговоре про пути к файлам, где фигурировала переменная PATH. Когда дело дойлёт у нас до пользовательских аккаунтов, придётся поговорить о переменных SHELL, USER, HOME.Все эти (и ещё некоторые) имена зарезервированы за внутренними, или встроенными, переменными оболочки (некий минимальный их набор имеется в любом шелле). То есть значения их определены раз и навсегда. и пользователем не изменяются. То есть он, конечно, может их изменить, если очень хочет — но ничего доброго, кроме путаницы, из этого не выйдет.Таких встроенных переменных довольно много. Одна из первых по значению — всё та же переменная PATH. Это — список каталогов, в которых оболочка, в ответ на ввод пользователя в командной строке, ищет исполнимые файлы — то есть просто команды. Я уже обращал внимание, что во всех приведённых выше примерах имена команд указывались без всяких путей к ним (в отличие от файлов-аргументов, путь к которым — обязателен). Так вот, успех её поисков и определяется списком значений переменной PATH. Каковые могут быть просмотрены командой echo:$ echo $PATHОбратим внимание на то, что в качества аргумента команды выступает не просто имя переменной, а оно же, но предваренное символом доллара. Который в данном случае никакого отношения к приглашению командной строки не имеет, а предписывает команде echo подменить имя переменной ее значением (значениями). В большинстве дистрибутивов Linux случае вывод команды для пользователя будет в обязательном порядке включать такие каталоги:/bin:/usr/bin:/usr/local/binДля администратора системы сюда обязательно добавятся каталоги /sbin, /usr/sbin и /usr/local/sbin. Остальные значения переменной PATH могут варьировать по умолчанию, а также задаваться пользователем (как — поговорим позже).Обратим вниммание на одно важное обстоятельство: практически во всех дистрибутивах Linux и в более иных ОС в перечне значений переменной PATH отсуствует текущий каталогТем временем вернемся к переменной HOME. Значение ее — полный абсолютный путь к домашнему каталогу пользователя. То есть, чтобы перейти в него, пользователю по имени alv вместо$ cd /home/alvдостаточно набрать$ cd $HOMEи он в своих владениях. Может показаться, что экономия — грошовая (тем паче, что перейти в собственный каталог пользователь может просто командой cd без всяких аргументов), но минуту терпения — и выгоду от использования переменных вы увидите.Кроме переменных, предопределенных в шелле, пользователю предоставляется почти полная свобода в определении переменных собственных. И вот тут-то и наступает ему обещанное облегчение при наборе аргументов команд.Предположим, что у нас имеется глубоко вложенный подкаталог с данными, постоянно требующимися в работе. Чисто условно примем, что путь к нему — следующий:/home/alv/data/all.my.works/geology/plate-tectonicsВесьма удручающе для набора, даже если исправно работать табулятором для автодополнения, не так ли? Прекрасно, упрощаем себе жизнь определением переменной:$ plate=/home/alv/data/all.my.works/geology/plate-tectonicsДело в шляпе, Теперь, если нам нужно просмотреть состав этого каталога, достаточно будет команды$ ls $plateА вызвать из него любой файл для редактирования можно так:$ joe $plate/filenameПодобно псевдонимам, переменные, определенные таким образом (то есть просто в командной строке), имеют силу только в текущем сеансе работы — по выходе из оболочки они утрачиваются. Для того, чтобы они действовали перманентно, переменные должны быть прописаны в конфигурационном файле пользовательского шелла. Однако, в отличие от псевдонимов, и этого оказывается не всегда достаточно. Ибо переменная, определенная посредством$ NAME=Valueработает не просто только в текущем сеансе — но ещё и только в конкретном экземпляре шелла. Почему и называется переменной оболочки — shell variable. Звучит это. быть может, пока не очень понятно. Однако практически любое действие в шелле — запуск команды или программы, например, — начинается с того, что оболочка, в которой это действие совершается, запускает новый экземпляр самой себя — дочерний шелл, или, как иногда говорят, субшелл.Так вот, этот самый субшелл не наследует переменные родительской оболочки. И в итоге запущенная из командной строки программа ничего не будет знать, например, о путях к исполняемым файлам. Что автоматически ведет к невозможности запуска из нее команд просто по имени, без указания точного пути.Чтобы избежать такой неприятной ситуации, было придумано понятие переменных окружения, или переменных среды — environment variable. Это — те переменные, которые наследуются от родительского шелла всеми дочерними программами. И чтобы сделать их таковыми, переменные следует экспортировать. Как? Командой export, которая может быть применена двояким образом. Можно сначала определить переменную:$ NAME=Valueа затем применить к ней команду export:$ export NAMEА можно сделать это в один прием:$ export NAME=ValueВторой способ применяется, если нужно определить и экспортировать одну переменную. Если же за раз определяется несколько переменных:$ NAME1=Value1;$ NAME2=Value2;...;$ NAMEN=ValueNто проще прибегнуть к первому способу, так как команда export может иметь сколько угодно аргументов:$ export NAME1 NAME2 ... NAMENТрадиционно имена переменных окружения задаются в верхнем регистре, переменных оболочки — в нижнем.Навигация и редактированиеИмя команды, ее опции и аргументы образуют т.н. командные «слова». В качестве словоразделителей выступают пробелы. Кроме того, как разделители «слов» интерпретируется ряд специальных символов — прямой слэш (/) — элемент пути к файлу, обратный слэш (\\), служащий для экранирования специальных символов, и операторы командных конструкций, о которых будет сказано ниже.В некоторых случаях имеет смысл различать «большое слово» и «малое слово». Первые разделяются пробелами, в качестве же вторых интерпретируются символы, лежащие между всеми другими словоразделителями.Подчеркнем, что командное «слово» прямо не соотносится ни с опциями, ни с аргументами команды. Введение этого понятия призвано просто облегчить навигацию в командной строке и ее редактирование.Ибо одно из великих достижений командного интерфейса POSIX-систем, заценить которое могут в полной мере только те, кто застал времена «черного DOS&#39;а», — это возможность перемещёния внутри командной строки и внесения необходимых изменений в имя команды, ее опции и аргументы. Делается это различными способами.Самый привычный и, казалось бы, очевидный способ — использование клавиш перемещёния курсора Left, Right, End и Home, действующих (хотя и не всегда) в командной строке точно так же, как и в каком-нибудь ворд-процессоре для Windows (клавиши Up, Down, PageUp, PageDown зарезервированы для других целей). То есть они позволяют перемещаться на один символ влево и вправо. в начало и конец командной строки. А если добавить сюда ещё клавиши Delete и Backspace, позволяющие удалять символы в позиции курсора или перед ней — то, казалось бы, чего ещё желать?Оказывается — есть чего, и самый очевидный способ навигации и редактирования оказывается не самым эффективным. Для начала заметим, что в общем случае привычные клавиши перемещёния курсора и редактирования в POSIX-системах не обязаны работать также, как они делают это в DOS/Windows. Это зависит от многих причин, в том числе и исторических. Ведь POSIX-системы по определению предназначены работать на любых практически машинах (в том числе и на тех, клавиатуры которых клавиш управления курсором просто не имели).Однако это не главное — в большинстве Linux-дистрибутивов командная оболочка по умолчанию настраивается так, чтобы пользователь при желании мог использовать привычные ему клавиши. Однако тут-то и оказывается, что плюс к этому оболочка предоставляет ему много более эффективную систему навигации по командной строке и ее редактирования. И это — система управляющих последовательностей, так называемых keybindings. То есть сочетания специальных клавиш, именуемых управляющими, с обычными алфавитно-цифровыми.Управляющие последовательностиОсновные управляющиеся клавиши, которые используются в таких последовательностях (и имеются на клавиатурах почти любых машин — как говорят в таких случаях, в любых типах терминалов) — это клавиши Control и Meta.Пардон — возразит внимательный читатель, — сколько я ни долблю по клавишам моей PC&#39;шки, но клавиши Meta не замечал. Возражение принято, но: на PC-клавиатурах функции Meta выполняют либо а) нажатие и отпускание клавиши Escape, либо б) нажатие и удерживание клавиши Alt.Впрочем, к этой теме я ещё вернусь. А пока достаточно нескольких простых рецептов, практически универсальных для любых командных оболочек в терминалах любых типов.Рецепт первый: большая часть управляющих последовательностей состоит из сочетания клавиши Control и алфавитно-цифрового символа. Под сочетанием (или комбинацией, для чего я уже употреблял ранее символ плюс) понимается то, что, удерживая нажатой клавишу Control, мы одновременно нажимаем и какую-нибудь литерную или цифровую.Так, действие клавишной комбинации Control+F (от Forward — в большинстве случаев регистр алфавитной клавиши управляющей последовательности значения не имеет) эквивалентно нажатию клавиши Right — это перемещёние на один символ вправо, комбинации Control+B (от Back) — нажатию Left (перемещёние на один символ влево). Комбинации Control+A и Control+E действуют аналогично Home и End, перемещая курсор в начало и конец командной строки, соответственно, Ну а с помощью комбинаций Control+D и Control+H можно удалить единичный символ в позиции курсора или перед ней (также, как и клавишами Delete и Backspace, соответственно).Предвижу резонный вопрос: а какие достоинства в комбинации клавиш Control+Что_то по сравнению с элементарными End или Left? Конечно, одно достоинство — очевидно: при массовом вводе команд (а также, забегая вперед, замечу — и любых иных наборов символов, от исходных текстов до романов), при использовании keybindings руки не отрываются от основной (алфавитно-цифровой) части клавиатуры. И в итоге, по приобретении некоторого минимального навыка, дело движется ну гораздо быстрее. Обосновать тестами не могу (тут какая-нибудь физиометрия понадобится), но не верящим — предлагаю попробовать.Главное же преимущество клавиатурных последовательностей перед стандартными навигационными клавишами — много более широкая их функциональность. Я не случайно начал этот параграф с упоминания командных «слов» — это, наряду с единичными символами, также навигационные (и, добавлю, редакционные) единицы командной строки. То есть управляющие последовательности позволяют при навигации и редактировании оперировать не только единичными символами, но и целыми словами.Например, комбинация Meta+F смещает курсор на одно «слово» вперед, та же Meta в сочетании с B — на одно слово назад, и так далее. Прошу обратить внимание: действие алфавитной клавиши в комбинации с Meta сходно по смыслу ее сочетанию с клавишей Control, но как бы «усилено»: последовательность Meta+D уничтожает не символ в позиции курсора, как это было бы для D в сочетании с Control, а все командное «слово».Рассматривать ключевые последовательности подробно здесь я не буду: детали их действия зависят от командной оболочки и ее настроек. Отмечу только два существенных обстоятельства. Первое: keybindings предоставляют пользователю полный комплекс приемов для любых действий в командной строке — вплоть до преобразования регистров уже введенных символов и «слов» (из нижнего в верхний и наоборот), «перетасовки» символов в команде или ее аргументах, и так далее.Значение управляющих последовательностей не ограничивается командной строкой — большинство популярных в POSIX-мире текстовых редакторов, от простых Nano или joe до грандиозного vim и монструозного emacs. построены по тому же принципу. Так что навыки, полученные при работе с keybindings, например, в Bash, весьма поспособствуют виртуозному освоению любого из этих инструментов.И второе — действие ключевых последовательностей, как правило. не зависит не только от типа терминала и физического устройства клавиатуры, но и от ее раскладки — при переключении на кириллицу они будут работать столь же справно, как и в латинице.История командВозможности навигации и редактирования строки особенно ярко проявляются в сочетании с другой замечательной особенностью, предоставляемой командными оболочками — доступом к истории команд. То есть: раз введенная в строке команда не уходит в небытие после исполнения, а помещается в специальный буфер памяти. Который, как и все в Unix&#39;ах, именуется весьма незатейливо — буфер истории команд. Откуда команда (со всеми её опциями и аргументами) может быть извлечена для повторного использования. Или — для редактирования и исполнения в новой реинкарнации.Буфер истории команд сохраняется в течении всего сеанса работы. Однако в большинстве случаев командные оболочки настраиваются так, что по выходе из сеанса буфер истории сохраняется в специальном файле в домашнем каталоге пользователя, и таким образом его содержимое оказывается доступным при следующем запуске шелла. Имя этого файла может быть различным в разных оболочках, но обычно включает компонент history (в Bash — ~/.bash_history).Так что, можно сказать, что введенным нами командам суждена вечная жизнь.Конечно, не совсем вечная. И размер буфера истории команд, и количество строк в файле истории — величины конечные. Так что, если установленный предел превышен, то старые команды вытесняются более новыми. Однако и величину буфера, и количество строк в файле истории можно установить любыми. Разумеется, в разумных пределах — не знаю, существует ли принципиальное ограничение на их размер, за исключением объёма памяти и дискового пространства. А если учесть, что и из буфера, и из памяти с помощью соответствующих настроек (со временем я расскажу, каких) можно исключить дубликаты и ещё кое-какой мусор — то мое заявление о вечной жизни команд не выглядит столь уж преувеличенным.Универсальное средство доступа к буферу истории команд — специальная команда, встроенная во все шеллы, таковой поддерживающие — history (в большинстве дистрибутивов Linux она по умолчанию имеет псевдоним — h). Данная без опций, эта команда выводит полный список команд в их исторической (издревле к современности) последовательности, или некоторое количество команд, определенных соответствующими настройками (о которых будет говориться позднее).В качестве опции можно указать желаемое количество одновременно выведенных команд. Например, директива$ history -2выведет две последние команды из буфера истории вместе с их номерами:1023  joe shell.html1024  less ~/.zshrcЛюбая из команд в буфере истории может быть повторно запущена на исполнение. Для этого достаточно набрать в командной строке символ ! (восклицательный знак) и затем, без пробела — номер команды в списке буфера. Например,$ !1023для приведенного выше примера повторно откроет файл shell.html в текстовом редакторе joe.Другой способ доступа к командам из буфера истории — комбинации клавиш Control+P и Control+N, служащие для последовательного его просмотра (как бы «пролистывания») назад и, соответственно, вперед (разумеется, если есть куда). Они дублируются клавишами управления курсором Up и Down (назад и вперед, соответственно). Кроме того, последовательности Meta+&lt; и Meta+&amp;rt; обеспечивают переход к первой и последней команде в буфере истории.Любая извлеченная (с помощью стрелок или управляющими последовательностями) из буфера истории в текущую строку команда может быть повторно запущена на исполнение — нажатием клавиши Enter или дублирующей ее комбинацией Control+M. причём предварительно ее можно отредактировать — изменить опции, или аргументы, — точно так же, как и только что введенную.Поиск в историиВо всех современных «развитых» шеллах предусмотрены средства поиска команды в буфере истории — простым перебором (обычно Meta+P — назад и Meta+N — вперед).Впрочем, не смотря на громкое название, обычный поиск ничем практически не отличается от пролистывания исторического списка курсорными стрелками. Что при обширной истории команд может быть весьма утомительным. И потому для ее облегчения предусмотрена такая интересная возможность, как наращиваемый поиск (incremental search) нужной команды в буфере истории по одному (или нескольким) из составляющих ее символов.Выполняется инкрементный поиск так: после нажатия (при пустой командной строке) клавишной комбинации Control+R появляется предложение ввести алфавитный символ (или — последовательность символов произвольной длины), заведомо входящий в состав требуемой команды:$ bck-i-search: _Ввод такого символа выведет последнюю из команд, его содержащих. При этом введенный символ будет отмечен знаком курсора. Он не обязан входить в имя команды, но может быть составляющим ее опций или аргументов (имени файла или пути к нему, например). Следующее нажатие Control+R зафиксирует курсор на предыдущем символе, в пределах этой же или более ранней по списку команды, и т.д. Однако вместо этого в строке поиска можно вводить дополнительные символы, детализирующие условия поиска команды (или — ее опций и аргументов).Процедуру поиска можно продолжать вплоть до достижения требуемого результата — то есть нахождения той команды, которая нужна именно сейчас. Нажатие клавиши Enter в любой из этих моментов запускает найденную (то есть помещённую в командную строку) команду на исполнение, с завершением поиска. Поиск обрывается также и нажатием комбинации Control+C. Перед запуском найденная команда может быть отредактирована стандартными средствами — с использованием управляющих последовательностей.Регулярные выраженияКак известно, все пользователи-POSIX&#39;ивисты должны быть в обязательном порядке привержены одному из семи смертных грехов. И грех этот — леность, можно сказать, показатель профессиональной пригодности линуксоида. В соответствие со своей леностью разработчики POSIX-систем придумывают способы, как бы им минимизировать свои усилия. А применители из лени изощряются в использовании этих приемов на практике. В частности — в том, как свести к минимуму набор в командной строке.Собственно говоря, этой цели служили почти все приемы, описанные выше. Осталось осветить немногое. А именно — регулярные выражения, реализуемые с помощью т.н. специальных символов (или метасимволов).Элементарная, и весьма частая, в духе школьных, задача: из каталога dir1 требуется скопировать все файлы в каталог dir2. Так неужели все они должны быть перечислены в качестве аргументов команды cp? Нет, нет, и ещё раз нет. Ибо для этой цели придуманы шаблоны имен файлов. Самый часто используемый из них — специальный символ * (вроде бы я о нем уже говорил?). Он подменяет собой любое количество любых символов (в том числе — и нулевое, то есть отсутствие символов вообще). То есть для решения предложенной задачи нам достаточно дать команду:$ cp dir1/* dir2Чуть усложним условия: к копированию из dir1 предназначены не все файлы, а только html-документы, традиционно имеющие суффикс html. Решение от этого не становится сложнее:$ cp dir1/*html dir2Однако тут можно вспомнить, что html-документы могут иметь и расширение htm. Не пропустим ли мы их таким образом при копировании? Таким — безусловно, пропустим. Однако нам на помощь придет другой шаблон — символ ?. А соответствует он любому единичному символу (или — его отсутствию, т.е. символу null). И значит, если команда из примера будет модифицирована таким образом:$ cp dir1/*htm? dir2то она гарантированно охватит все возможные маски html-документов.Вроде все хорошо. Однако нет: из каталога dir1 нам нужно скопировать только три определенных файла — file1, file2, file3. Не придется ли каждый из них указывать в командной строке с полным путем (а ведь они могут быть и в глубоко вложенном подкаталоге типа dir1/dir11/dir111)? Все равно не придется, на столь хитрую... постановку задачи у нас есть прием с левой резьбой — символы группировки аргументов, обозначаемые фигурными скобками. Что на практике выглядит так:$ cp path/{file1,file2,file3} dir2И приведет к единоразовому копированию всех трех файлов в каталог dir2. Заметим, что сгруппированные аргументы разделяются запятыми без пробелов. И ещё: в оболочке Bash группируемые аргументы придется полностью вводить руками. Но вот в Zsh на них распространяется возможность автодополнения, да и запятая после каждого имени появляется автоматически (и столь же автоматически исчезает при закрытии фигурной скобки).Группировка аргументов может быть сколь угодно глубоко вложенной. Так, команда$ mkdir -p dir1/{dir11/{dir111,dir112},dir12/{dir121,dir122}}в один заход создаст трехуровневую структуру каталогов внутри текущего — если только не забыть про опцию -p, которая предписывает создавать промежуточные подкаталоги в случае их отсутствия.И ещё несколько примеров. Регулярное выражение для диапазона — то есть вида [...], подменяет любой из символов, заключенных в квадратные скобки. Символы эти могут даваться списком без пробелов (например, выражение [12345] соответствует любому символу от 1 до 5) или определяться в диапазоне, крайние значения которого разделяются дефисом без пробелов (эквивалентное первому выражение — [1-5]). Кроме того, символ ^, предваряющий список или диапазон, означает отрицание: выражение [^abc] подменяет любой символ, исключая символы a, b и c.Последние примеры регулярных выражений могут показаться надуманными. Однако представим. что в том же каталоге dir1, кроме html-документов, содержатся также файлы изображений в различных форматах — GIF, JPEG, TIFF и так далее (традиционно имеющие одноименные расширения). И все они должны быть скопированы в каталог dir2, а вот как раз html-файлы нам в данный момент без надобности. No problemas, как говорят у них:$ cp dir1/*[^html] dir2И в каталоге dir2 окажется все содержимое каталога dir1, за исключением html-файлов.ЭкранированиеИз приведённых примеров можно видеть, что метасимволы, образующие регулярные выражения, интерпретируются командной оболочкой особым образом, не так, как обычные алфавитно-цифровые символы, составляющие, скажем, имена файлов.В то же время собственно POSIX-системы накладывают на имена файлов очень мало ограничений. И в принципе система не запретит вам создать файл с именем, содержащим метасимволы. Другое дело, что работать с таким образом именованными файлами может быть сложно — командная оболочка будет пытаться интерпретировать их в соответствии с правилами для регулярных выражений.Конечно, использовать метасимволы в именах файлов весьма не рекомендуется. Однако а) возможны элементарные ошибки при наборе, и б) файлы, полученные при обмене с другими операционными системами (сами знаете. какими), могут иметь довольно непривычный (и, я даже сказал бы, неприличный) вид.Вспомним, что MS Word в качестве имени файла спокойно берёт первую фразу документа. А если это — вопрос? И тогда завершающий имя символ ? будет в шелле интерпретироваться как шаблон, а не как элемент имени. Думаю, не нужно обладать очень развитым воображением, чтобы представить последствия. Что делать в таких ситуациях? Для их разрешения резонными людьми придумано было понятие экранирования.Начнём с первого примера использования экранирования — разрыва длинных строк. Командные директивы, с многочисленными их опциями, особенно в полной форме, и аргументами могут оказаться весьма длинными, не укладывающимися в пределы экранной строки. Правда, обычно командная оболочка по умолчанию настраивается с разрешением так называемого word wrapping&#39;а (то есть переноса «слов» команды без обрыва строки — последнее, как мы помним, достигается нажатием клавиши Enter или комбинации Control+M и приводит к немедленному исполнению введённой команды. Если ввод ее не окончен — последует сообщение об ошибке). Однако перенос «слов» при этом происходит, как бог на душу положит. И в результате командная директива теряет читабельность и становится сложной для понимания.Тут-то и приходит на помощь понятие экранирования, упомянутое абзацем выше. Знак экранирования — обратный слэш (\\), — превращает символ, имеющий специальное значение, например, упоминавшийся ранее шаблон в именах файлов — *, в самую обычную звездочку. А раз конец строки — тоже символ, хотя и специальный, то и он доступен для экранирования. Так что если завершить введённый фрагмент команды обратным слэшем (некоторые оболочки требуют предварить его пробелом, и лучше так и делать, хотя в Bash или Zsh пробел не обязателен), после чего нажать Enter, то вместо попытки исполнения будет образована новая строка. в которой можно продолжать ввод. Вид приглашения к вводу при этом изменится — это будет так называемое вторичное приглашение командной строки, и его представление настраиваемо, также как и вид приглашения первичного.Возвращаемся к экранированию обратным слэшем. Действие его распространяется только на непосредственно следующий за ним символ. Если символы, могущие быть воспринятые как специальные, идут подряд, каждый из них должен предваряться обратным слэшем.У обратного слэша есть ещё одна интересная особенность — я назвал бы ее инвертированием специального значения символов. Для примера: некая последовательность цифр (например, 033), введенная в командной строке, будет воспринята как набор обычных символов. Однако она же может выступать как код какого-либо символа (в частности, 033 — код символа Escape в восьмеричной системе счисления). И подчас возникает необходимость ввода таких кодов (тот же код для Escape, скажем, затруднительно ввести каким-либо иным образом).И вот тут обратный слэш проявляет свое инвертирующее действие: последовательность \\033 будет восприниматься уже не как набор символов, а как код символа Escape (обратим внимание, что тут достаточно единичного слэша). Непосредственно в командной строке такой способ инвертированного экранирования, по понятным причинам, обычно не используется, но находит широкое применение в сценариях.О кавычкахЕсть и экраны, распространяемые на все, что заключено внутри них. Это — кавычки, двойные и одинарные: большая часть символов между ними утрачивает свое специальное значение. Но не все: в двойных кавычках сохраняют специальное значение метасимволы $ и \\, а также обратные кавычки (`), о назначении которых я скажу чуть позже. То есть в них сохраняется возможность, с одной стороны, получения значений переменных (как мы помним, с помощью $ИМЯ). А с другой стороны, если нам требуется дать символ бакса в его прямом и привычном значении, у нас есть возможность заэкранировать его обратным слэшем. И если потребуется вывести на экран сообщение «с вас, уважаемый, пятьсот баксов», то это можно сделать таким образом:$ echo &quot;с вас, уважаемый, \\$500&quot;ещё одно широко применяемое использование двойных кавычек — экранирование пробелов, предотвращающих разбиение аргументов команды на отдельные «слова». Правда, в случае с командой echo это, как правило, не требуется (хотя настоятельно рекомендуется экранировать ее аргумент таким образом). Однако представьте, что в качестве аргумента команды копирования и перемещёния выступает файл, переписанный с Windows-машины. Ведь там пробелы в именах — вещь обычная. Тут-то экранирование двойными кавычками и придется к месту.Из сказанного понятно, почему двойные кавычки именуются ещё неполными, или не строгими — они все же допускают внутри себя использование символов со специальными значениями. В противоположность им, кавычки одинарные носят имя строгих, или полных. Потому что между ними утрачивают специальное значение все метасимволы, кроме их самих — в том числе и символ единичного экранирования. В итоге они используются там, где гарантированно требуется отсутствие специальных символов. Если вы помните, мы применили строгие кавычки при установке псевдонимов. Они же часто оказываются обязательными при определении переменных.Завершая тему экранирования, осталось сказать только об обратных кавычках. Их функция очень узка: они служат для экранирования команд. То есть, скажем, команда$ echo dateв полном соответствие со своим именем, просто выведет нам собственный аргумент:dateОднако если аргумент команды закрыть обратными кавычками, то date будет воспринято как имя команды, подлежащей исполнению. И результат этого исполнения (то есть текущая дата и время — а именно для их получения и предназначена команда date) будет замещать имя команды в выводе echo:$ echo `date`Втр Дек 16 11:45:12 MSK 2003Если вспомнить, что обратные кавычки сохраняют свое специальное значение внутри кавычек двойных, становится ясной польза от их применения: они незаменимы в тех случаях, когда требуется вывод результатов работы одной команды внутри другой. К как в нашем примере с выводом даты, если его (вывод) следует включить в некое выдаваемое командой echo сообщение.Конечно, в описанном случае добиться той же цели можно было бы гораздо легче — просто командой date. Однако представьте, что у нас возникло желание одновременно и получить сведения о количестве пользователей в системе (для чего предназначена команда who). Тут-то и выясняется. что проще всего это сделать командой типа следующей:$ echo &quot;На момент `date` в системе        зарегистрированы `who`&quot;Ответом на что будет сообщение, подобное тому, что часто можно наблюдать на главной странице многих сайтов:На момент Сб. дек. 20 06:05:56 MSK 2014 в системезарегистрированы alv      tty8         2014-12-15 00:34 (:0)alv      pts/1        2014-12-15 00:34 (:0)alv      pts/5        2014-12-19 09:37 (:0)А теперь последнее, чем и закроем тему регулярных выражений вообще. В этом разделе рассматривалось использование метасимволов в командной оболочке (конкретно, в данном случае. в Dash, Bash и Zsh). В других оболочках применение метасимволов и условия их экранирования могут несколько отличаться. И к тому же многие запускаемые из строки шелла команды могут иметь свои правила построения регулярных выражений. Так что в итоге их форма определяется сочетанием особенностей конкретной оболочки и команды, из неё запущенной. Все это при необходимости будет оговариваться в дальнейшем.А пока переходим к рассмотрению командных конструкций — одной из тех особенностей CLI, которая определяет мощь и универсальность этого интерфейса.Вводные слова о командных конструкцияхНадеюсь, из того, что было рассказано на предшествующих страницах, посвящённых CLI, читателю стало ясно, что подавляющее большинство команд в POSIX-системах очень просты по сути и предназначены для выполнения какого-либо одного элементарного действия.То есть команда cp умеет только копировать файлы, команда rm — только удалять их, но зато делают они это хорошо. Подчас — через чур хорошо, что мог ощутить на себе каждый, кому «посчастливилось» по ошибке выдать директиву вроде$ rm -Rf *Для тех, кто не испытал этого волнительного ощущения, поясню: результатом будет полное и безвозвратное уничтожение всех файлов от текущего каталога вниз (включая подкаталоги любой степени вложенности).А если задать ту же команду от лица администратора, то, в зависимости от текущего положения на файловом древе, можно нечувствительно удалить что угодно, вплоть до системы целиком: одна из причине, почему повседневные действия не следует выполнять под root&#39;ом.Собственно, разделение любой задачи на серию элементарных операций — это и есть основной принцип работы в POSIX-системах, тот самый пресловутый Unix-way, о котором столько говорят его приверженцы.Однако вслед за этапом решительного размежевания (эх, неистребимы в памяти нашего поколения слова товарища Ленина) должен наступить этап объединения, как за анализом явления следует синтез эмпирических данных о нём. И целям такого объединения служат командные конструкции.Командные конструкции — очень важный компонент интерфейса командной строки. Они позволяют объединять несколько команд воедино и выполнять различные команды последовательно или параллельно. Для этого служат специальные символы — операторы: фонового режима, объединения, перенаправления и конвейеризации.Совместное выполнение командПростейшая командная конструкция — это выполнение команды в фоновом режиме, что вызывается вводом символа амперсанда после списка опций и (или аргументов):$ command [options] [arguments] &amp;В Bash и Zsh пробел перед символом амперсанда не обязателен, но в некоторых шеллах он требуется, и потому лучше возвести его ввод (как и во всех аналогичных случаях) в ранг привычки. После этого возвращается приглашение командной строки и возможен ввод любых других команд (в том числе и фоновых). Команды для параллельного исполнения можно задать и в той же строке:$ command1 &amp; command2 &amp; ... &amp; commandNВ результате все команды, перечисленные в строке, кроме той, что указана последней, будут выполняться в фоновом режиме.Существуют и конструкции для последовательного выполнения команд. Так, если ряд команд разделен в строке символом точки с запятой (;)$ command1 ; command2 ; ... ; commandNто сначала будет выполнена команда command1, затем — command1 и так далее. Молчаливо предполагается, что каждая из этих команд может иметь любое количество опций и аргументов. И, опять-таки, обрамление ; пробелами не обязательно во многих командных оболочках. Сами по себе команды не обязаны быть связанными между собой каким-либо образом — в сущности, это просто эквивалент последовательного их ввода в командной строке:$ command1$ command2...и так далее. При этом первая команда может, например, копировать файлы, вторая — осуществлять поиск, третья — выполнять сортировку, или другие действия. Очевидно, что в общем случае выполнение последующей команды не зависит от результатов работы предшествующей.Однако возможна ситуация, когда результаты предыдущей команды из такой конструкции используются в команде последующей. В этом случае ошибка исполнения любой составляющей команды, кроме последней, делает невозможным продолжение работы всей конструкции. Что само по себе было бы ещё полбеды — однако в некоторых ситуациях исполнение последующей команды возможно только при условии успешного завершения предыдущей.Характерный пример — сборка программы из ее исходных текстов, включающая три стадии — конфигурирование, собственно компиляцию и установку собранных компонентов. Что обычно выполняется последовательностью из трёх команд:$ ./configure$ make$ make installЯсно, что если конфигурирование завершилось ошибкой, то компиляция начаться не сможет и, соответственно, потом нечего будет устанавливать. И потому объединение их в последовательную конструкцию вида$ ./configure ; make ; make installможет оказаться нецелесообразным.Однако для предотвращения таких ситуаций в конструкции из взаимосвязанных команд существует другой оператор, обозначаемый удвоенным символом амперсанда — &amp;&amp;. Он указывает, что последующая команда конструкции должна исполняться только в том случае, если предыдущая завершилась успешно:$ ./configure &amp;&amp; make &amp;&amp; make installНа практике обе приведённые в качестве примера конструкции дадут один и тот же результат — разумеется, если все составляющие их команды будут выполнены без ошибок. Однако в ряде иных случаев различие между этими конструкциями может быть существенным.Впрочем, предусмотрена и командная конструкция, в которой последующей команде предписано исполняться в том и только в том случае, если предыдущая команда завершилась неудачно. Она имеет вид$ command1 || command2и может служить, в частности, для вывода сообщений об ошибках.ПеренаправлениеСледующая командная конструкция — это так называемое перенаправление ввода/вывода. Чтобы понять,что это такое, нужно помнить две вещи:любая команда получает данные для своей работы (например, список опций и аргументов) со стандартного устройства ввода (которым в первом приближении будем считать клавиатуру), а результаты своей работы представляет на стандартном устройстве вывода (коим договоримся считать экран монитора);POSIX-системах любое устройство — не более чем имя специального файла, именуемого файлом устройства.Таким образом, ничто не запрещает нам подменить специальный файл устройства ввода или устройства вывода любым иным файлом (например, обычным текстовым). Откуда и будут в этом случае браться входные данные или куда будет записываться вывод команды.Перенаправление вывода команды обозначается следующим образом:$ command &gt; filenameили$ command &gt;&gt; filenameВ первом случае (одиночный символ &gt;) вывод команды command образует содержимое нового файла с именем filename, не появляясь на экране. Или, если файл с этим именем существовал ранее, то его содержимое подменяется выходным потоком команды (точно также, как при копировании одного файла в другой, уже существующий). Почему такое перенаправление называется замещающим (или перенаправлением в режиме замещёния).Во втором же случае (двойной символ &gt;&gt;) происходит добавление вывода команды command в конец существующего файла filename (при отсутствии же его в большинстве случаев просто образуется новый файл). И потому это называется присоединяющим перенаправлением, или перенаправлением в режиме присоединения.Перенаправление ввода выглядит так:$ command &lt; filenameПростейший случай перенаправления вывода — сохранение результата исполнения команды в обычном текстовом файле. Например, конструкция$ ls dir1 &gt; listсоздаст файл, содержанием которого будет список файлов каталога dir1. А в результате выполнения конструкции$ ls dir2 &gt;&gt; listк этому списку добавится и содержимое каталога dir2.При перенаправлении ввода команда получает данные для своей работы из входящего в командную конструкцию файла. Например, конструкция$ sort &lt; listвыведет на экран строки файла list, отсортированных в порядке возрастания значения ASCII-кода первого символа, а конструкция$ sort -r &lt; listосуществит сортировку строк того же файла в порядке, обратном алфавитному (вернее, обратном порядку кодов символов, но это нас в данном случае не волнует).В одной конструкции могут сочетаться перенаправления ввода и вывода, как в режиме замещёния, так и в режиме присоединения. Так, конструкция$ sort -r &lt; list &gt; list_rне только выполнит сортировку строк файла list (это — назначение команды sort) в обратном алфавитному порядке (что предписывается опцией -r, происходящей в данном случае от reverce), но и запишет ее результаты в новый файл list_r, а конструкция$ sort -r &lt; list &gt;&gt; listдобавит по-новому отсортированный список в конец существующего файла list.КонвейерыВозможности построения командных конструкций не ограничиваются перенаправлением ввода/вывода: результаты работы одной команды могут быть переданы для обработки другой команде. Это достигается благодаря механизму программных каналов (pipe) или конвейеров — последний термин лучше отражает существо дела.При конвейеризации команд стандартный вывод первой команды передается не в файл, а на стандартный ввод следующей команды. Простой пример такой операции — просмотр списка файлов:$ ls -l | lessПеренаправление вывода команды ls, то есть списка файлов, который при использовании полного формата записи (опция -l) может занимать многие экраны, на ввод команды less позволяет просматривать результат с ее помощью постранично или построчно в обоих направлениях.Конвейеризация команд может быть сколь угодно длинной. Возможно также объединение конвейеризации команд и перенаправления в одной конструкции. Кроме того, команды в конструкции могут быть сгруппированы с тем, чтобы они выполнялись как единое целое. Для этого группа команд разделяется символами ; и пробелами, как при последовательном выполнении команд, и заключается в фигурные скобки. Так, если нам требуется перенаправить вывод нескольких команд в один и тот же файл, вместо неуклюжей последовательности типа$ command1 &gt; file ; command2 &gt;&gt; file ; ... ; commandN &gt;&gt; fileможно прибегнут к более изящной конструкции:$ { command1 ; command2 ; ... ; commandN } &gt; fileКак и многие из ранее приведённых примеров, этот может показаться надуманным. Однако представьте, что вам нужно создать полный список файлов вашего домашнего каталога, разбитый по подкаталогам, да ещё и с комментариями, в каком подкаталоге что находится. Конечно, можно вывести состав каждого подкаталога командой ls, слить их воедино командой cat (она предназначена, в частности, и для объединения — конкатенации, — файлов, и речь о ней будет позже), загрузить получившееся хозяйство в текстовый редактор или ворд-процессор, где добавить необходимые словеса. А можно — обойтись единой конструкцией:$ { echo &quot;List of my files&quot; ;  &gt; echo &quot;My text&quot; ;        ls text/* ;  &gt; echo &quot;My images&quot; ;        ls images/* ;  &gt; echo &quot;My audio&quot; ;        ls audio/* ;  &gt; echo &quot;My video&quot; ;        ls video/* } &gt; my-filelistИ в результате получить файл такого (условно) содержания, которое мы для разнообразия просмотрим с помощью только что упомянутой команды cat (благо и для просмотра содержимого файлов она также пригодна):$ cat my-filelistList of my filesMy texttext/text1.txt text/text2.txtMy imagesimages/img1.tif images/img2.tifMy audioaudio/sing1.mp3 audio/sing2.mp3My videovideo/film1.avi video/film2.aviПонятие о фильтрахС понятием командных конструкций тесно связано понятие программ-фильтров. Это — команды, способные принимать на свой ввод данные с вывода других команд, производить над ними некоторые действия и перенаправлять свой вывод (то есть результат модификации полученных данных) в файлы или далее по конвейеру — другой команде.Программы-фильтры — очень эффективное средство обработки текстов, и в своё время мы к ним вернемся для подробного изучения. Пока же важно отметить, что в качестве фильтров могут работать не все команды. Например, команды find или grep фильтруют имена файлов или фрагменты их содержимого, а команда ls фильтром не является.Сценарии оболочкиНаш затянувшийся разговор о командах и командном интерфейсе подходит к концу. И в заключение этого раздела — ещё немного терпения. Потому что было бы несправедливо не уделить чуть-чуть места тому, что придает командному интерфейсу POSIX-систем его несравненную гибкость и универсальность. Заодно способствуя закоснению пользователя в смертном грехе лености. Итак — слово о сценариях оболочки.В самом начале я обмолвился, что шелл — это не просто среда для ввода единичных команд и командных конструкций, но и ещё интерпретатор собственного языка программирования. Так вот, сценарии оболочки, именуемые также скриптами, — это и есть программы, написанные на этом языке.Только не заподозрите меня в гнусном намерении учить вас программерству. Господь борони, и в мыслях не держал (тем паче, что и сам-то этим ремеслом не владею в должной для обучения других степени). Нет, просто на последующих страницах нам то и дело придётся рассматривать кое-какие примеры готовых сценариев, а подчас и пытаться создавать их собственноручно. Ибо занятие это в элементарном исполнении навыков программирования не требует вообще.В самом простом случае сценарий — это просто одна или несколько команд или (и) командных конструкций с необходимыми опциями и аргументами, сохраненные в виде обычного именованного текстового файла. И предназначены они в первую очередь для автоматизации часто исполняемых рутинных операций, в частности, ввода длинных последовательностей в командной строке.Создание пользовательского сценария — просто, как правда. Для этого всего и нужно:создать командную конструкцию, достойную увековечивания;поместить ее в простой текстовый файл;по потребности и желанию снабдить комментариями;тем или иным способом запустить файл на исполнение.С принципами создания команд и командных конструкций мы в первом приближении разобрались раньше. А вот способов помещёния их в файл существует множество. Можно просто ввести (или вызвать из буфера истории) нужную команду и оформить ее как аргумент команды echo, вывод которой перенаправить в файл:$ echo &quot;cp -rf workdir backupdir&quot; &gt; mybackupТаким образом мы получили простейший скрипт для копирования файлов из рабочего каталога в каталог для резервного хранения данных, что впредь и будем проделывать регулярно (не так ли?).Аналогичную процедуру можно выполнить с помощью команды cat — она, оказывается, способна не только к объединению файлов и выводу их содержимого, но и к вводу в файл каких-либо данных. Делается это так. Вызываем cat с перенаправлением ее вывода в файл:$ cat &gt; myarchiveи нажимаем Enter. После этого команда остается в ожидании ввода данных для помещёния их в новообразованный файл. Не обманем ее ожиданий и проделаем это. причём можно не жаться и выполнить ввод в несколько строк, например:cd $HOME/archivedir tar cf archive.tar        ../workdir gzip archive.tarЗавершив ввод тела скрипта, все той же клавишей Enter открываем новую строку и набираем комбинацию Control+D, выдающую символ окончания файла.В результате получаем сценарий для архивирования в специально предназначенном для этого каталоге archivedir наших рабочих данных (командой tar), а заодно и их компрессии (командой gzip) — в Unix, в отличие от DOS/Windows, архивирование и компрессия обычно рассматриваются как разные процедуры.Наконец, сценарий можно создать в любом текстовом редакторе. но это не так интересно — по крайней мере, пока. Да и стоит ли вызывать редактор ради двух-трёх строк?Комментариями в шелл-сценариях считаются любые строки, начинающиеся с символа решетки (#) — они не учитываются интерпретатором и не принимаются к исполнению. Хотя комментарий может быть начат и внутри строки — важно только, что между символом # и концом её больше ничего не было бы. Ясно, что комментарии — элемент для скрипта не обязательный, но очень желательный. Хотя бы для того, чтобы не забыть, ради чего этот сценарий создавался.Но одна строка, начинающаяся символом решётки, в сценарии практически обязательна. И должна она быть первой и выглядеть следующим образом:#!/path/shell_nameВ данном случае восклицательный знак подчеркивает, что предваряющий его символ решетки (#) — не комментарий, а указание (т.н. sha-bang) на точный абсолютный путь к исполняемому файлу оболочки, для которой наш сценарий предназначен, например,#!/bin/shдля POSIX-шелла, или#!/bin/bashдля оболочки Bash. Здесь следует подчеркнуть, что шелл, для которого предназначается сценарий, отнюдь не обязан совпадать с командной оболочкой пользователя. И полноты картины для замечу, что указание точного имени интерпретатора требуется не только для шелл-скриптов, но и для программ на любых языках сценариев (типа Perl или Python).Так что по хорошему в обоих приведенных выше примерах ввод команд сценария следовало бы предварить строкой sha-bang. Конечно, отсутствие имени командной оболочки в явном виде обычно не помешает исполнению шелл-сценария: для этого будет вызван системный командный интерпретатор по умолчанию — в Mint /bin/dash. Однако если сценарий предназначен для другой командной оболочки, то без sha-bang он может исполняться неправильно (или не исполняться вообще).Теперь остается только выполнить наш сценарий. Сделать это можно разными способами. Самый напрашивающийся — непосредственно вызвать требуемый шелл как обычную команду, снабдив его аргументом — именем сценария (предположим, что он находится в текущем каталоге):$ bash scriptnameДалее, для вызова скриптов существует специальная встроенная команда оболочки, обозначаемая символом точки. Используется она аналогично:$ . ./scriptnameс тем только исключением, что тут требуется указание текущего каталога в явном виде (что и символизируется ./).Однако наиболее употребимый способ запуска сценариев — это присвоение его файлу так называемого атрибута исполнения. Эта процедура волшебным образом превращает невзрачный текстовый файлишко во всамделишную (хотя и очень простую) программу.Так вот, после присвоения нашему сценарию бита исполнения запустить его можно точно также, как любую другую команду — просто из командной строки:$ ./scriptnameОпять же — в предположении, что сценарий находится в текущем каталоге (./), иначе потребуется указание полного пути к нему. Что, понятно, лениво, но решается раз и навсегда: все сценарии помещаются в специально отведенный для этого каталог (например, $HOME/bin), который и добавляется в качестве ещё одного значения переменной PATH данного пользователя.Понятие о функцияхИ уж совсем в заключение этого раздела осталось сказать пару слов о функциях командной оболочки. Это — такая же последовательность команд (или даже просто одиночная команда), как и сценарий, но — не вынесенная в отдельный исполняемый файл, а помещённая в тело другого скрипта. В коем она опознаётся по имени, и может быть выполнена неоднократно в ходе работы этого скрипта.Главное отличие функции от сценария — в том, что она выполняется в том же процессе (и, соответственно, экземпляре шелла), что и заключающий её сценарий. Тогда как для каждого скрипта, вызываемого из другого сценария, создаётся отдельный процесс, порождающий собственный экземпляр шелла. Это может быть важным, если в сценарии определяются некоторые переменные, которые имеют силу только в нём самом.Функции не обязательно помещаются внутрь сценария — их можно собрать в некоторые отдельные файлы, которые именуются библиотеками функций и могут быть использованы по мере надобности.Ранее на протяжении всего повествования неоднократно упоминались (и будут упоминаться впредь) системные библиотеки, в частности, главная библиотека glibc. Так вот, это — точно такие же сборники функций, правда, не командной оболочки, а языка Си, и, соответственно, хранящиеся не в виде текстовых файлов, а в бинарном, откомпилированном, виде.Настройка шеллаВо всех дистрибутивах Linux в качестве пользовательской командной оболочки по умолчанию выступает Bash, и Mint здесь не исключение. Так что, хотя автор этих строк не является ни её любителем, ни, тем более, знатоком, совсем обойти её вниманиемне мог. Так что ниже даётся мини-очерк настройки этого шелла.Оболочка Bash поддерживает все интерактивные возможности, столь важные для пользователя, как то: автодополнение для команд и путей к файлам, историю оных (включая средства инкрементного поиска), мощные возможности навигации и редактирования командной строки.Важно, что существует дополнительный пакет bash-completion: установка его обогащает базовую оболочку множеством опциональных средств настройки автодополнения (в том числе и для командных аргументов). Правда, чтобы эта дополненная оболочка была по настоящему удобной и функциональной, нужно приложить некоторые усилия по её настройке, чем мы сейчас и займёмся.Схема настройки bash предусматривает наличие пары файлов /etc/profile и /etc/bashrc (для логин-шелла и просто интерактивного его экземпляра), а также соответствующих им пользовательских конфигов — ~/.bash_profile и ~/.bashrc. При авторизации первым в любом случае считывается общесистемный профильный файл /etc/profile, вслед за ним — пользовательский профильный файл ~/.bash_profile, после чего происходит обращение к ~/.bashrc. Файл /etc/profile может занимать особое положение — в него часто помещают переменные окружения (например, локально-зависимые), которые должны быть общими для всех пользователей данной системы. Пользовательские же настройки определяются в файлах ~/.bash_profile и ~/.bashrc. Обычно в ~/.bash_profile определяются переменные окружения, которые должны действовать для всех дочерних процессов, а в ~/.bashrc — параметры, всегда требуемые в интерактивном режиме (например, псевдонимы).Редактирование командной строки в bash обеспечивается отдельным пакетом — библиотекой функций readline. Она имеет собственные конфигурационные файлы, общесистемный /etc/inputrc и пользовательский ~/.inputrc.Впрочем, в большинстве современных дистрибутивов Linux, ориентированных на графический режим и, следовательно, использование эмулятора терминала с интерактивным шеллом, не являющимся, тем не менее, шеллом пользовательским (login shell), ~/.bash_profile играет сугубо служебную роль, и содержимое его сводится к отработке файла ~/.bashrc:# include .bashrc if it existsif [-f ~/.bashrc]; then. ~/.bashrcfi# set PATH so it includes user&#39;s private bin if it existsif [-d ~/bin] ; thenPATH=~/bin:&quot;${PATH}&quot;fiИменно в ~/.bashrc и выполняются при этом все пользовательские настройки.Большинство настроек Bash по умолчанию разумны, и потому наличные в данном дистрибутиве файлы вполне могут быть взяты за основу. Однако путём некоторых несложных действий их можно дополнить, увеличив удобство интерактивного использования командной оболочки.По умолчанию в Bash автодополнение клавишей табулятора не работает, например, в аргументах многих команд, таких, как sudo или man.Решается эта задача очень просто: достаточно файл ~/.bashrc внести следующие строки:# enable bash completion in interactive shellsif [-f /etc/bash_completion]; then . /etc/bash_completionfiПосле этого автодополнение будет работать буквально везде, где только можно себе представить, например, после набора dpkg --sea и нажатия табулятора получится dpkg --search.Если в файл /etc/inpurc (или в ~/inpurc) добавить такие строки:&quot;e[A&quot;: history-search-backward&quot;e[B&quot;: history-search-forwardто набор части команды, например, cd /, и последующий перебор стрелками &lt;Up&gt; и &lt;Down&gt; истории команд повлечёт извеление из буфера истории только тех из них, которые начинаются на cd /."
},







{
"title": "About this theme",
"tags": "",
"keywords": "",
"url": "doc_about.html",
"summary": "",
"body": "TODO"
},




{
"title": "Start",
"tags": "",
"keywords": "",
"url": "index.html",
"summary": "",
"body": "Cinnamon - является оригинальной графической средой (desktop environment) для Linux Mint.Данный проект русскоязычной документации по Linux Mint Cinnamon полностью базируется на книге Алексея Федорчука aka Alv: Linux Mint и его CinnamonЧитать:Linux Mint Cinnamon (17.1 Rebecca)Суть данного проекта:предоставление актуальной и легко сопровождаемой документации по Linux Mint Cinnamonконсолидация людей работающих на данной ОСДля этого:поднятие генерации html на базе системы генерации Jekyllдизайн с адаптивной версткой (просмотр на мобильных устройствах)перевод книги в MarkDownвыкладывание на githubсоздание для каждой версии Cinnamon - отдельной веткивозможность добавления других языков (не только русского)Сделано:создан базовый код и адаптирован html шаблон для Jekyllисходный код текста вынесен в отдельный репозиторий (для каждого языка)добавлена ветка для 17.1 версииоригинальная html книга разбита на html фрагменты по главамчастично переведены главы в MarkDownToDo:обновить Jekyll (c 2.5.3 на 3.0.1)перенести картинки в githubперевести все главы книги в MarkDownзакончить по версии Cinnamon 17.1&quot;вычистить&quot; html/css тему от лишних артефактов[DONE] возможность навигации между страницамидобавить ветки 17.2/17.3 - и актуализировать информацию для этих версий (текст, картинки)вынесение русскоязычных строк из основного конфиг файла в отдельный конфиг файл (в папке ru)Структура папок:linuxmint-cinnamon (сюда генерируется html контент)linuxmint-cinnamon-jekyll (здесь html/css/js тема, шаблоны, конфиги для Jekyll и симлинк на контент)linuxmint-cinnamon-ru-17-1-Rebecca (здесь находится контент, согласно языку и версии-ветка)Исходный код:https://github.com/linuxmint-cinnamon-manual/linuxmint-cinnamon-jekyllhttps://github.com/linuxmint-cinnamon-manual/linuxmint-cinnamon-ruУстановка и работа:устанавливается Jekyll (сейчас 2.5.3 версия)создаются папки, и выкачиваются соотв. git репозиториисоздаётся симлинк на контент (из папки с jekyll проектом)стартуется Jekyllгенерирует код в linuxmint-cinnamon папкубраузером открывается локальный веб-сервер поднятый Jekyll - и просматривается сгенерированный контентредактируется шаблон или контентJekyll - автоматически перегенерирует папку (секунд 5)сгенерированный html выкладывается в репозиторий https://github.com/linuxmint-cinnamon-manual/linuxmint-cinnamon-manual.github.ioи становится (автоматически) доступен по адресу http://linuxmint-cinnamon-manual.github.io/Конфигурационные файлы:основной конфиг для Jekyll - _config.yml_data/sidebar_doc.yml - левая навигационная панельпапки _includes и _layouts содержат html шаблоны (в формате Liquid)папки css, fonts, images, js - содержат стилевое оформление (за основу была взята эта тема)Содержимое:содержимое находится в папке ru, и соответствующей версии подпапке (сейчас 17-1-Rebecca)для того чтобы отображение и содержимое не пересекались - всё содержимое книги вынесено в отдельный репозиторий, но т.к. для Jekyll всё содержимое должно быть внутри - сделан симлинк изнутри Jekyll папки, на папку ссодержимым книги так же для того чтобы можно было сопровождать новые версии - для каждой версии планируется одноимённая ветка (branch), сейчас есть ветка 17-1-Rebecca, далее будет 17-2-Rafaela и т.п. Таким образом все фиксы можно легко &quot;мержить&quot; из 17.1 в 17.2 (17.3), и так же добавлять новый текст в новых версиях (на базе предыдущего контента).вкратце инструкция по настройке папок здесьОбсуждение:гугл группа linuxmint2ru"
},




{
"title": "Аннотация",
"tags": "",
"keywords": "",
"url": "ru17-1-Rebeccaindex.html",
"summary": "",
"body": "Эта книга посвящена дистрибутиву Linux Mint и одной из его главных рабочихсред рабочих сред — десктопу Cinnamon. В ней рассмотрены их особенности,средства настройки дистрибутива и среды, системы управления пакетами,некоторые прикладные программы. Затронут также ряд более специальных вопросов,имеющих отношение не только к Linux Mint, такие, как командная оболочка Zsh,использование программных RAID, технологии LVM и системы размещения данныхZFS. Заключительным аккордом в ней прозвучит рассказ о создании собственныхиндивидуализированных сборок на базе Linux Mint и Cinnamon.Книга не является систематическим руководством по данному дистрибутиву и, темболее, по Linux вообще. Она ориентирована исключительно на любопытствующихприменителей любого уровня подготовки, имеющих склонность к экспериментам, содной стороны, и к изящной словесности — с другой."
},
























null
]


